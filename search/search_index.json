{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The <code>tokamak_neutron_source</code> package provides a method of generating neutron sources for tokamak fusion device.</p> <p>Neutron sources can be generated from EQDSK files and custom profiles for export to neutron transport codes.</p>"},{"location":"#installation","title":"Installation","text":"<p>We don't try to manage the installation of your neutronics codes. We recommend you install your neutronics code first. If you are using <code>tokamak-neutron-source</code> to create an OpenMC source a simple install of OpenMC using <code>conda</code> can be done with:</p> <pre><code>conda install -c conda-forge 'openmc&gt;=0.15.0'\n</code></pre> <p>To install the latest release of <code>tokamak-neutron-source</code></p> <pre><code>pip install tokamak-neutron-source\n</code></pre>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Theory</li> <li>Plasma Profiles</li> <li>Equilibrium Information</li> <li>Units and Conventions</li> <li>Supported Neutron Transport Codes</li> </ul>"},{"location":"codes/","title":"Supported Neutron Transport Codes","text":""},{"location":"codes/#exporting-a-neutron-source","title":"Exporting a neutron source","text":"<p><code>tokamak_neutron_source</code> is designed to be able to create neutron sources for use in any neutron transport code. At present, interfaces for two codes are supported:</p>"},{"location":"codes/#openmc","title":"OpenMC","text":"<p><code>tokamak_neutron_source</code> is able to export a neutron source in native OpenMC format, via the specification of a list of <code>openmc.IndependentSource</code>. When creating the source, the default OpenMC units are used (eV and cm). Exercise caution if you have configured OpenMC to operate with a different set of units. This functionality requires you to have OpenMC installed in the same environment.</p> <p>If multiple neutronic fusion reactions are specified, the energy distributions are combined into a single source at each point.</p>"},{"location":"codes/#mcnp-6","title":"MCNP-6","text":"<p>TODO: Add documentation when this functionality exists.</p>"},{"location":"equilibrium/","title":"Equilibrium information","text":"<p>A <code>TokamakNeutronSource</code> requires the specification of some distribution of poloidal magnetic flux in the poloidal plane. This is in order to determine the strength of the source at a given spatial location. The poloidal magnetic flux distribution is used to interpolate the 1-D plasma profiles (temperature and density) in 2-D cylindrical coordinates.</p>"},{"location":"equilibrium/#equilibrium-parameterisations","title":"Equilibrium parameterisations","text":"<p>By means of a parameterisation, such as the one described in (Fausser et al., 2012) and made available here via the <code>FausserFluxSurface</code> class.</p> <p></p> <p>This flux surface parameterisation is a simplified description of the poloidal magnetic flux in a tokamak and, rather unrealistically, maintains constant \\(\\kappa(\\psi_n)\\) and \\(\\delta(\\psi_n)\\) - constant elongation and triangularity as a function of normalised poloidal magnetic flux. Nevertheless it provides an easy way to specify a pseudo-equilibrium.</p> <p>All that is required to specify a new parameterisation is the specification of a method that returns a spatial description of a closed flux surface as a function of a normalised \\(\\psi_n\\). This calculation must produce a C2 flux distribution (i.e. the flux surfaces may not overlap).</p>"},{"location":"equilibrium/#actual-equilibrium","title":"Actual equilibrium","text":"<p>By means of an equilibrium file, typically an EQDSK file.</p> <p></p> <p>Here a free boundary equilibrium is shown. The source is only calculated within the last closed flux surface.</p>"},{"location":"profiles/","title":"Plasma profiles","text":"<p>Plasma ion temperature and fuel ion density profiles are required to calculate the neutron emission rates from the plasma.</p> <p>These can be specified either by typical plasma profile parameterisations, or via actual profiles resulting from experiment or simulation.</p>"},{"location":"profiles/#profile-parameterisations","title":"Profile parameterisations","text":"<p>Plasma profiles can be generated via common parameterisations, such as the parabolic-pedestal form found in various systems codes.</p> <p></p> <p>Here the fuel ion density composition is treated as constant across the profile.</p>"},{"location":"profiles/#actual-profiles","title":"Actual profiles","text":"<p>One can instantiate the plasma profiles directly from data. Here the fuel ion densities must be specified, and need not have constant concentrations across the profile.</p> <p></p>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#fusion-reactions","title":"Fusion reactions","text":"<p>The following reactions are presently supported:</p> \\[ \\begin{aligned} \\textrm{DT}: \\textrm{D}+ \\textrm{T} &amp;\\rightarrow \\!{}^4_2\\textrm{He}~(3.52~\\textrm{MeV}) + \\textrm{n} ~(14.06~\\textrm{MeV}) \\\\ \\textrm{DD}_{[1]}: \\textrm{D}+ \\textrm{D} &amp;\\rightarrow \\!{}^3_2\\textrm{He}~(0.82~\\textrm{MeV}) + \\textrm{n} ~(2.45~\\textrm{MeV}) \\\\ \\textrm{DD}_{[2]}: \\textrm{D}+ \\textrm{D} &amp;\\rightarrow \\textrm{T}~(1.01~\\textrm{MeV}) + \\textrm{p}~(3.02~\\textrm{MeV}) \\\\ \\textrm{TT}: \\textrm{T} + \\textrm{T} &amp;\\rightarrow \\!{}^4_2\\textrm{He}~(6.83~\\textrm{MeV})\\textrm{n}~(9.0~\\textrm{MeV}) + \\textrm{n}~(2.5~\\textrm{MeV}) \\\\ \\textrm{DHe3}: \\textrm{3} + \\!{}^3_2\\textrm{He} &amp;\\rightarrow \\!{}^4_2\\textrm{He}~(14.66~\\textrm{MeV}) + \\textrm{p}~(3.69~\\textrm{MeV}) \\\\ \\end{aligned} \\]"},{"location":"theory/#fusion-reactivities","title":"Fusion reactivities","text":"<p>The reactivities \\(\\langle \\sigma\\nu\\rangle_{XY}\\) are velocity-averaged assuming a Maxwellian distribution. Both Bosch-Hale and direct cross-section integral methods are available to calculate the reactivies.</p> <p></p>"},{"location":"theory/#neutron-source-strength","title":"Neutron source strength","text":"<p>The local tokamak neutron source strength (the number of reactions) is calculated assuming reactions between two reactants X and Y with Maxwellian velocity distributions.</p> \\[ \\dfrac{N_{XY}}{dV} = \\dfrac{1}{1+\\delta_{XY}}n_X(\\psi_n)n_Y(\\psi_n)\\langle\\sigma\\nu\\rangle_{XY}(T_i(\\psi_n)) \\] <p>where:</p> <ul> <li>\\(N_{XY}\\) is the number of reactions between reactants X and Y</li> <li>\\(\\delta_{XY}\\) is the Kronecker delta (0.0 for different reactants, and 1.0 for the same)</li> <li>\\(n_X, n_Y\\) is the on density of reactants X and Y</li> <li>\\(\\langle \\sigma\\nu\\rangle_{XY}\\) is the velocity-averaged reactivity of reaction X-Y</li> </ul> <p>The total number of reactions is integrated across the whole plasma, all reactions, and all channels:</p> \\[ N_{total} = \\sum_R \\sum_c \\int \\dfrac{1}{1+\\delta_{XY}}n_X(\\psi_n)n_Y(\\psi_n)\\langle\\sigma\\nu\\rangle_{XY}(T_i(\\psi_n))dV \\] <p>In practice, the aneutronic D-D channel is ignored, but is accounted for when renormalising a to a user-prescribed fusion power.</p>"},{"location":"theory/#neutron-energies","title":"Neutron energies","text":"<p>The neutron energies are provided in terms of probability density functions (PDFs). For the D-D and D-T reactions, these are calculated following Ballabio et al., 1998. For the T-T reaction (a three-body reaction with two neutrons), a single neutron spectrum is provided, interpolated from data kindly supplied from Appelbe and Chittenden, 2016.</p> <p></p>"},{"location":"theory/#plasma-profiles","title":"Plasma profiles","text":"<p>The plasma fuel ion density and temperature profiles are required in order to calculate the neutron source strength.</p> <p>These profiles are 1-D in the normalised radial coordinates, which we call \\(\\rho\\) here. By convention \\(\\rho\\) is 0 at the magnetic axis, and 1 at the plasma boundary, which for our purposes is explicitly defined here as the last closed flux surface (LCFS).</p> <p>To interact coherently with the plasma equilibrium description \\(\\rho\\) is converted to the normalised poloidal magnetic flux \\(\\psi_n\\) which follows the opposite convention, name \\(\\psi_n\\) is 1 at the magnetic axis and 0 at the plasma boundary. There are two commonly used conventions for \\(\\psi_n\\) which are supported here:</p> <ul> <li>\\(\\psi_n = \\dfrac{\\psi_a - \\psi}{\\psi_a - \\psi_b}\\)</li> <li>\\(\\psi_n = \\sqrt{\\dfrac{\\psi_a - \\psi}{\\psi_a - \\psi_b}}\\)</li> </ul> <p>These relate essentially to the preservation of area and volume across flux surfaces, respectively. Equilibrium solvers often use the former, transport solvers often use the latter. It is important that the plasma profiles are clearly specified with the appropriate convention for your use case.</p>"},{"location":"theory/#plasma-equilibrium","title":"Plasma equilibrium","text":"<p>The plasma equilibrium description is used to position the neutron source. All that is required is a spatial description of \\(\\psi_n\\), and the coordinates of the LCFS. From this, one can calculate \\(\\psi_n\\) at an arbitrary location in cylindrical coordinates \\((x, z)\\) where, by axisymmetry, \\(\\phi\\) can be ignored.</p> <p>The ion density and temperature can then be calculated at \\((x, z)\\) via interpolation of \\(\\psi_n\\), e.g. \\(T_i(\\rho(\\psi_n(x, z)))\\).</p>"},{"location":"units/","title":"Units and conventions","text":""},{"location":"units/#units","title":"Units","text":"<p>All length quantities are units of <code>[m]</code>, and all temperature / energy quantities are in <code>[keV]</code>. For time, we use <code>[s]</code>.</p>"},{"location":"units/#conventions","title":"Conventions","text":""},{"location":"units/#source-strength","title":"Source strength","text":"<p>Following a common practice in neutronics, the fixed source strength is normalised to 1 <code>[neutrons/s]</code>. Tallies can then be multiplied by the <code>source_rate</code> to obtain total values, as and when required.</p> <p>If you are using a \"(n,Xt)\" tally to calculate TBR, note that the definition of TBR is relative to the number of tritons consumed by the plasma, not the total number of fusion reactions.</p> <p>To correctly scale your \"(n,Xt)\" tally in [1/particles], you should scale by:     <code>tbr *= source_rate / source_T_rate</code></p> <p>to obtain the correct TBR. This is of course only relevant if you specify reactions in addition to the D-T reaction.</p> <p>Note that the source strengths are not quantised; i.e., the rates are floats, not integers.</p>"},{"location":"units/#equilibrium-coordinate","title":"Equilibrium coordinate","text":"<p>For the <code>FluxMap</code>, some description of the plasma magneto-hydrodynamic equilibrium is required. Regardless of whether this is provided via an EQDSK file or a parameterisation, the convention for the calculation of the normalised coordinate, should be specified correctly. This can be done using the <code>FluxConvention</code> enum. Here we use the normalised flux coordinate, \\(\\psi_n\\), which we define as being 1.0 at the magnetic axis, and 0.0 at the edge. The corresponding equilibrium radial coordinate, \\(\\rho\\), follows the opposite trend; 0.0 at the magnetic axis, and 1.0 at the edge.</p> <p>Two methods are available for the specification for the poloidal magnetic flux (\\(\\psi\\)):</p> <ul> <li><code>FluxConvention.LINEAR</code>: \\(\\psi_n = \\dfrac{\\psi_{a} - \\psi}{\\psi_{a} - \\psi_{b}}\\)</li> <li><code>FluxConvention.SQRT</code>: \\(\\psi_n = \\sqrt{\\dfrac{\\psi_{a} - \\psi}{\\psi_{a} - \\psi_{b}}}\\)</li> </ul> <p>Note that if an equilibrium is loaded from a file, the COCOS convention is made irrelevant here: we treat the flux map such that it complies with the inner workings of the code.</p>"},{"location":"examples/energies.ex/","title":"Neutron energy spectra","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Neutron energies.\"\"\"\n</pre> # SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"Neutron energies.\"\"\" In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nfrom tokamak_neutron_source import Reactions\nfrom tokamak_neutron_source.energy import EnergySpectrumMethod, energy_spectrum\n</pre>  import matplotlib.pyplot as plt  from tokamak_neutron_source import Reactions from tokamak_neutron_source.energy import EnergySpectrumMethod, energy_spectrum In\u00a0[\u00a0]: Copied! <pre>_f, ax = plt.subplots()\n\nfor reaction, color in zip(\n    [Reactions.D_D, Reactions.D_T, Reactions.T_T], [\"r\", \"g\", \"b\"], strict=False\n):\n    for temperature, ls in zip([10.0, 20.0], [\"-.\", \"-\"], strict=False):\n        e, pdf = energy_spectrum(temperature, reaction)\n        ax.plot(\n            e,\n            pdf / max(pdf),\n            color=color,\n            ls=ls,\n            label=f\"{reaction.label}, T = {temperature} keV\",\n        )\nax.set_xlabel(r\"$E_{n}$ [keV]\")\nax.set_ylabel(\"[a. u.]\")\nax.legend()\nplt.show()\n</pre>  _f, ax = plt.subplots()  for reaction, color in zip(     [Reactions.D_D, Reactions.D_T, Reactions.T_T], [\"r\", \"g\", \"b\"], strict=False ):     for temperature, ls in zip([10.0, 20.0], [\"-.\", \"-\"], strict=False):         e, pdf = energy_spectrum(temperature, reaction)         ax.plot(             e,             pdf / max(pdf),             color=color,             ls=ls,             label=f\"{reaction.label}, T = {temperature} keV\",         ) ax.set_xlabel(r\"$E_{n}$ [keV]\") ax.set_ylabel(\"[a. u.]\") ax.legend() plt.show() <p>Here we attempt to recreate Fig. 5 of Ballabio et al</p> In\u00a0[\u00a0]: Copied! <pre>temperature = 20.0\nenergy, prob = energy_spectrum(temperature, Reactions.D_T)\n\n_f, ax = plt.subplots()\nax.semilogy(energy, prob)\nax.set_xlim([12e3, 17e3])\nax.set_ylim([10e-11, 10e-3])\nax.set_title(\"D-T neutron spectrum at 20 keV\")\nax.set_xlabel(\"En [keV]\")\nax.set_ylabel(\"[a. u.]\")\nplt.show()\n</pre>  temperature = 20.0 energy, prob = energy_spectrum(temperature, Reactions.D_T)  _f, ax = plt.subplots() ax.semilogy(energy, prob) ax.set_xlim([12e3, 17e3]) ax.set_ylim([10e-11, 10e-3]) ax.set_title(\"D-T neutron spectrum at 20 keV\") ax.set_xlabel(\"En [keV]\") ax.set_ylabel(\"[a. u.]\") plt.show() In\u00a0[\u00a0]: Copied! <pre>temperature = 20.0  # [keV]\n\nfor reaction in [Reactions.D_D, Reactions.D_T]:\n    energy1, g_pdf = energy_spectrum(\n        temperature, reaction, method=EnergySpectrumMethod.BALLABIO_GAUSSIAN\n    )\n    energy2, mg_pdf = energy_spectrum(\n        temperature, reaction, method=EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n    )\n    _f, ax = plt.subplots()\n    ax.set_title(f\"{reaction.name} neutron energy spectrum at 20 keV\")\n    ax.semilogy(energy1, g_pdf, label=f\"{reaction.name} Gaussian\")\n    ax.semilogy(energy2, mg_pdf, label=f\"{reaction.name} modified Gaussian\")\n    ax.set_xlabel(r\"$E_{n}$ [keV]\")\n    ax.set_ylabel(\"[a. u.]\")\n    ax.legend()\n    plt.show()\n</pre>  temperature = 20.0  # [keV]  for reaction in [Reactions.D_D, Reactions.D_T]:     energy1, g_pdf = energy_spectrum(         temperature, reaction, method=EnergySpectrumMethod.BALLABIO_GAUSSIAN     )     energy2, mg_pdf = energy_spectrum(         temperature, reaction, method=EnergySpectrumMethod.BALLABIO_M_GAUSSIAN     )     _f, ax = plt.subplots()     ax.set_title(f\"{reaction.name} neutron energy spectrum at 20 keV\")     ax.semilogy(energy1, g_pdf, label=f\"{reaction.name} Gaussian\")     ax.semilogy(energy2, mg_pdf, label=f\"{reaction.name} modified Gaussian\")     ax.set_xlabel(r\"$E_{n}$ [keV]\")     ax.set_ylabel(\"[a. u.]\")     ax.legend()     plt.show() <p>Here we recreate Fig 1. of Appelbe and Chittenden</p> <p>temperatures = [1.0, 5.0, 10.0, 20.0]</p> <p>f, ax = plt.subplots() for temp in temperatures: energy, intensity = energy_spectrum(temp, Reactions.T_T, EnergySpectrumMethod.DATA) ax.plot(energy, intensity / max(intensity), label=f\"Ti = {temp} keV\") ax.legend() ax.set_title(\"T-T neutron energy spectrum\") ax.set_xlim([1e3, 1e4]) ax.set_ylim([0, 1]) ax.set_xlabel(r\"$E_n$ [keV]\") ax.set_ylabel(\"[a. u.]\") plt.show()</p>"},{"location":"examples/energies.ex/#neutron-energy-spectra","title":"Neutron energy spectra\u00b6","text":"<p>Here we look in detail at the neutron energy spectra for the D-T, D-D, and T-T fusion reactions.</p> <p>The D-T and D-D spectra are calculated following Ballabio et al.'s parameterisations.</p> <p>The T-T spectra are interpolated from data produced by Appelbe and Chittenden.</p>"},{"location":"examples/energies.ex/#comparison-between-normal-and-modified-gaussian-distributions-from-ballabio-et-al","title":"Comparison between normal and modified Gaussian distributions from Ballabio et al.\u00b6","text":"<p>The differences are subtle, default is to use the modified Gaussian as specified in the paper.</p>"},{"location":"examples/fausser.ex/","title":"Fausser Source","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Example using the Fausser Flux surface parameterisation\"\"\"\n</pre> # SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"Example using the Fausser Flux surface parameterisation\"\"\" In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nfrom tokamak_neutron_source import (\n    FluxMap,\n    FractionalFuelComposition,\n    TokamakNeutronSource,\n    TransportInformation,\n)\nfrom tokamak_neutron_source.flux import FausserFluxSurface, LCFSInformation\nfrom tokamak_neutron_source.profile import ParabolicPedestalProfile\nfrom tokamak_neutron_source.reactions import Reactions\n</pre>  import numpy as np  from tokamak_neutron_source import (     FluxMap,     FractionalFuelComposition,     TokamakNeutronSource,     TransportInformation, ) from tokamak_neutron_source.flux import FausserFluxSurface, LCFSInformation from tokamak_neutron_source.profile import ParabolicPedestalProfile from tokamak_neutron_source.reactions import Reactions In\u00a0[\u00a0]: Copied! <pre>temperature_profile = ParabolicPedestalProfile(30.0, 5, 0.1, 1.45, 2.0, 0.95)  # [keV]\ndensity_profile = ParabolicPedestalProfile(1e20, 2e19, 0.5e16, 1.0, 2.0, 0.95)\nrho_profile = np.linspace(0, 1, 500)\n\nsource = TokamakNeutronSource(\n    transport=TransportInformation.from_parameterisations(\n        ion_temperature_profile=temperature_profile,\n        fuel_density_profile=density_profile,\n        rho_profile=rho_profile,\n        fuel_composition=FractionalFuelComposition(D=0.5, T=0.5),\n    ),\n    flux_map=FluxMap.from_parameterisation(\n        FausserFluxSurface(\n            LCFSInformation(9.0, 0.0, 3.1, 1.8, 0.4, 0.5),\n        ),\n        rho_profile=rho_profile,\n    ),\n    source_type=[Reactions.D_T, Reactions.D_D],\n    cell_side_length=0.1,\n)\nf, ax = source.plot()\n</pre> temperature_profile = ParabolicPedestalProfile(30.0, 5, 0.1, 1.45, 2.0, 0.95)  # [keV] density_profile = ParabolicPedestalProfile(1e20, 2e19, 0.5e16, 1.0, 2.0, 0.95) rho_profile = np.linspace(0, 1, 500)  source = TokamakNeutronSource(     transport=TransportInformation.from_parameterisations(         ion_temperature_profile=temperature_profile,         fuel_density_profile=density_profile,         rho_profile=rho_profile,         fuel_composition=FractionalFuelComposition(D=0.5, T=0.5),     ),     flux_map=FluxMap.from_parameterisation(         FausserFluxSurface(             LCFSInformation(9.0, 0.0, 3.1, 1.8, 0.4, 0.5),         ),         rho_profile=rho_profile,     ),     source_type=[Reactions.D_T, Reactions.D_D],     cell_side_length=0.1, ) f, ax = source.plot()"},{"location":"examples/fausser.ex/#fausser-source","title":"Fausser Source\u00b6","text":""},{"location":"examples/from_eqdsk.ex/","title":"Creation from an EQDSK file.","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Example reading from eqdsk file\"\"\"\n</pre> # SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"Example reading from eqdsk file\"\"\" In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nfrom tokamak_neutron_source import (\n    FluxMap,\n    FractionalFuelComposition,\n    TokamakNeutronSource,\n    TransportInformation,\n)\nfrom tokamak_neutron_source.profile import ParabolicPedestalProfile\n</pre>  import numpy as np  from tokamak_neutron_source import (     FluxMap,     FractionalFuelComposition,     TokamakNeutronSource,     TransportInformation, ) from tokamak_neutron_source.profile import ParabolicPedestalProfile In\u00a0[\u00a0]: Copied! <pre>temperature_profile = ParabolicPedestalProfile(25.0, 5.0, 0.1, 1.45, 2.0, 0.95)  # [keV]\ndensity_profile = ParabolicPedestalProfile(0.8e20, 0.5e19, 0.5e17, 1.0, 2.0, 0.95)\nrho_profile = np.linspace(0, 1, 30)\n\nsource = TokamakNeutronSource(\n    transport=TransportInformation.from_parameterisations(\n        ion_temperature_profile=temperature_profile,\n        fuel_density_profile=density_profile,\n        rho_profile=rho_profile,\n        fuel_composition=FractionalFuelComposition(D=0.5, T=0.5),\n    ),\n    flux_map=FluxMap.from_eqdsk(\"tests/test_data/eqref_OOB.json\"),\n    cell_side_length=0.05,\n)\nf, ax = source.plot()\n</pre> temperature_profile = ParabolicPedestalProfile(25.0, 5.0, 0.1, 1.45, 2.0, 0.95)  # [keV] density_profile = ParabolicPedestalProfile(0.8e20, 0.5e19, 0.5e17, 1.0, 2.0, 0.95) rho_profile = np.linspace(0, 1, 30)  source = TokamakNeutronSource(     transport=TransportInformation.from_parameterisations(         ion_temperature_profile=temperature_profile,         fuel_density_profile=density_profile,         rho_profile=rho_profile,         fuel_composition=FractionalFuelComposition(D=0.5, T=0.5),     ),     flux_map=FluxMap.from_eqdsk(\"tests/test_data/eqref_OOB.json\"),     cell_side_length=0.05, ) f, ax = source.plot() In\u00a0[\u00a0]: Copied! <pre>print(f\"Total fusion power: {source.calculate_total_fusion_power() / 1e9} GW\")\nsource.normalise_fusion_power(2.2e9)\nprint(f\"Total fusion power: {source.calculate_total_fusion_power() / 1e9} GW\")\n</pre> print(f\"Total fusion power: {source.calculate_total_fusion_power() / 1e9} GW\") source.normalise_fusion_power(2.2e9) print(f\"Total fusion power: {source.calculate_total_fusion_power() / 1e9} GW\")"},{"location":"examples/from_eqdsk.ex/#creation-from-an-eqdsk-file","title":"Creation from an EQDSK file.\u00b6","text":""},{"location":"examples/from_eqdsk.ex/#normalising-fusion-power","title":"Normalising fusion power\u00b6","text":"<p>We can calculate the total fusion power from the reactions specified.</p> <p>However, this may not correspond to some reference value we obtain from another code. There are many reasons why this may be the case:</p> <ul> <li>Different reactivity parameterisations or XS data</li> <li>Different interpolation of poloidal magnetic flux</li> <li>Limitations of cell-based discretisation (vs flux surface integrals)</li> </ul> <p>We can correct for this:</p>"},{"location":"examples/from_jetto.ex/","title":"JETTO Source","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Example Reading from JETTO files\"\"\"\n</pre> # SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"Example Reading from JETTO files\"\"\" In\u00a0[\u00a0]: Copied! <pre>from tokamak_neutron_source import (\n    FluxConvention,\n    FluxMap,\n    TokamakNeutronSource,\n    TransportInformation,\n)\nfrom tokamak_neutron_source.reactions import Reactions\n</pre>  from tokamak_neutron_source import (     FluxConvention,     FluxMap,     TokamakNeutronSource,     TransportInformation, ) from tokamak_neutron_source.reactions import Reactions In\u00a0[\u00a0]: Copied! <pre>source = TokamakNeutronSource(\n    transport=TransportInformation.from_jetto(\"tests/test_data/STEP_jetto.jsp\"),\n    flux_map=FluxMap.from_eqdsk(\n        \"tests/test_data/STEP_jetto.eqdsk_out\", flux_convention=FluxConvention.SQRT\n    ),\n    source_type=[Reactions.D_T, Reactions.D_D],\n    cell_side_length=0.05,\n)\n\n# Print the calculated total neutron rate from the ion density and temperature profiles\nprint(\"Total D-D source neutrons:\", sum(source.strength[Reactions.D_D]))\n\nprint(\"Calculated total source fusion power: \", source.calculate_total_fusion_power())\n\nsource.plot()\n</pre>  source = TokamakNeutronSource(     transport=TransportInformation.from_jetto(\"tests/test_data/STEP_jetto.jsp\"),     flux_map=FluxMap.from_eqdsk(         \"tests/test_data/STEP_jetto.eqdsk_out\", flux_convention=FluxConvention.SQRT     ),     source_type=[Reactions.D_T, Reactions.D_D],     cell_side_length=0.05, )  # Print the calculated total neutron rate from the ion density and temperature profiles print(\"Total D-D source neutrons:\", sum(source.strength[Reactions.D_D]))  print(\"Calculated total source fusion power: \", source.calculate_total_fusion_power())  source.plot()"},{"location":"examples/from_jetto.ex/#jetto-source","title":"JETTO Source\u00b6","text":"<p>These JETTO data are available here: https://gitlab.com/jintrac/jetto-pythontools/-/tree/1.8.13/testdata?ref_type=tags</p>"},{"location":"examples/reactivities.ex/","title":"Reactivities","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Reactivities.\"\"\"\n</pre> # SPDX-FileCopyrightText: 2024-present Tokamak Neutron Source Maintainers # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"Reactivities.\"\"\" In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom tokamak_neutron_source.reactions import AneutronicReactions, Reactions\nfrom tokamak_neutron_source.reactivity import (\n    ReactivityMethod,\n    reactivity,\n)\n</pre>  import matplotlib.pyplot as plt import numpy as np  from tokamak_neutron_source.reactions import AneutronicReactions, Reactions from tokamak_neutron_source.reactivity import (     ReactivityMethod,     reactivity, ) In\u00a0[\u00a0]: Copied! <pre>temperature = np.logspace(0, 3, 1000)\n\nf, ax = plt.subplots(figsize=[12, 10])\n\nxs_reactivities = {}\nfor reaction in [\n    Reactions.D_T,\n    Reactions.D_D,\n    AneutronicReactions.D_D,\n    Reactions.T_T,\n    AneutronicReactions.D_He3,\n]:\n    xs_reactivities[reaction] = reactivity(\n        temperature, reaction, method=ReactivityMethod.XS\n    )\n    ax.loglog(\n        temperature, xs_reactivities[reaction], lw=1.5, label=f\"{reaction.label} XS\"\n    )\n\nbh_reactivities = {}\nfor reaction in [Reactions.D_T, Reactions.D_D, AneutronicReactions.D_D]:\n    bh_reactivities[reaction] = reactivity(\n        temperature, reaction, method=ReactivityMethod.BOSCH_HALE\n    )\n    ax.loglog(\n        temperature,\n        bh_reactivities[reaction],\n        \"--\",\n        lw=1.5,\n        label=f\"{reaction.label} Bosch-Hale\",\n    )\n\nax.set_ylim([1e-27, 2e-21])\nxticks = np.array([1, 10, 100, 1000])\nax.set_xticks(xticks)\nax.set_xticklabels([str(x) for x in xticks])\nax.grid(visible=True, which=\"both\", axis=\"both\")\nax.set_xlabel(\"Temperature [keV]\")\nax.set_ylabel(r\"$&lt;\\sigma v&gt;$ [m$^3$/s]\")\nax.legend()\nplt.show()\nf.savefig(\"reactivities.svg\", dpi=600, format=\"svg\")\n</pre>  temperature = np.logspace(0, 3, 1000)  f, ax = plt.subplots(figsize=[12, 10])  xs_reactivities = {} for reaction in [     Reactions.D_T,     Reactions.D_D,     AneutronicReactions.D_D,     Reactions.T_T,     AneutronicReactions.D_He3, ]:     xs_reactivities[reaction] = reactivity(         temperature, reaction, method=ReactivityMethod.XS     )     ax.loglog(         temperature, xs_reactivities[reaction], lw=1.5, label=f\"{reaction.label} XS\"     )  bh_reactivities = {} for reaction in [Reactions.D_T, Reactions.D_D, AneutronicReactions.D_D]:     bh_reactivities[reaction] = reactivity(         temperature, reaction, method=ReactivityMethod.BOSCH_HALE     )     ax.loglog(         temperature,         bh_reactivities[reaction],         \"--\",         lw=1.5,         label=f\"{reaction.label} Bosch-Hale\",     )  ax.set_ylim([1e-27, 2e-21]) xticks = np.array([1, 10, 100, 1000]) ax.set_xticks(xticks) ax.set_xticklabels([str(x) for x in xticks]) ax.grid(visible=True, which=\"both\", axis=\"both\") ax.set_xlabel(\"Temperature [keV]\") ax.set_ylabel(r\"$&lt;\\sigma v&gt;$ [m$^3$/s]\") ax.legend() plt.show() f.savefig(\"reactivities.svg\", dpi=600, format=\"svg\")"},{"location":"examples/reactivities.ex/#reactivities","title":"Reactivities\u00b6","text":"<p>Here we show the reactivities of the various fusion reactions implemented in <code>tokamak_neutron_source</code>.</p> <p>We can also compare the two available methods:</p> <ul> <li>Cross-section integration (Maxwellian assumption)</li> <li>Bosch-Hale parameterisations</li> </ul> <p>The Bosch-Hale parameterisations for reactivity are used by default, as they are ubiquitous in fusion research. However, they are not available for all reactions, and have limited validity above &gt; 100 keV.</p>"},{"location":"source/reference/overview/","title":"Overview","text":"<ul> <li>tokamak_neutron_source<ul> <li>constants</li> <li>energy</li> <li>energy_data</li> <li>error</li> <li>flux</li> <li>main</li> <li>mcnp_interface</li> <li>openmc_interface</li> <li>profile</li> <li>reactions</li> <li>reactivity</li> <li>reactivity_data</li> <li>space</li> <li>tools</li> <li>transport</li> </ul> </li> </ul>"},{"location":"source/reference/tokamak_neutron_source/constants/","title":"constants","text":"<p>A collection of generic physical constants, conversions, and miscellaneous constants.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.ANGLE","title":"<code>ANGLE = &lt;Unit('degree')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.CURRENT","title":"<code>CURRENT = &lt;Unit('ampere')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.C_LIGHT","title":"<code>C_LIGHT = 299792458.0</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.DENSITY","title":"<code>DENSITY = &lt;Unit('kilogram / meter ** 3')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.D_MOLAR_MASS","title":"<code>D_MOLAR_MASS = 2.01410177784</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.ELECTRON_MASS","title":"<code>ELECTRON_MASS = 9.1093837139e-31</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.ELECTRON_MOLAR_MASS","title":"<code>ELECTRON_MOLAR_MASS = 0.0005485799096195737</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.ELEMENTARY_CHARGE","title":"<code>ELEMENTARY_CHARGE = 1.602176634e-19</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_CHARGE","title":"<code>E_CHARGE = 1.602176634e-19</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_DD_HE3N_FUSION","title":"<code>E_DD_HE3N_FUSION = 5.237367559215132e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_DD_NEUTRON","title":"<code>E_DD_NEUTRON = 3.924425728571561e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_DD_TP_FUSION","title":"<code>E_DD_TP_FUSION = 6.461016407480568e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_DHE3_FUSION","title":"<code>E_DHE3_FUSION = 2.940668400408501e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_DT_FUSION","title":"<code>E_DT_FUSION = 2.8183035155819573e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_DT_NEUTRON","title":"<code>E_DT_NEUTRON = 2.250912784396904e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_TT_FUSION","title":"<code>E_TT_FUSION = 1.8157845541890245e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.E_TT_NEUTRON","title":"<code>E_TT_NEUTRON = 7.546109313264398e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.FLUX_DENSITY","title":"<code>FLUX_DENSITY = &lt;Unit('1 / meter ** 2 / second')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.HE3_MOLAR_MASS","title":"<code>HE3_MOLAR_MASS = 3.01602932197</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.HE_MOLAR_MASS","title":"<code>HE_MOLAR_MASS = 4.002602</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.H_PLANCK","title":"<code>H_PLANCK = 1.0545718176461565e-34</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.K_BOLTZMANN","title":"<code>K_BOLTZMANN = 1.380649e-23</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.LENGTH","title":"<code>LENGTH = &lt;Unit('meter')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.MASS","title":"<code>MASS = &lt;Unit('kilogram')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.MOLAR_MASSES","title":"<code>MOLAR_MASSES = {'D': 2.01410177784, 'T': 3.01604928132, 'He': 4.002602, 'He3': 3.01602932197, 'n': 1.0086649171167301, 'p': 1.0072764676333197, 'e': 0.0005485799096195737}</code>  <code>module-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.NEUTRON_MOLAR_MASS","title":"<code>NEUTRON_MOLAR_MASS = 1.0086649171167301</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.N_AVOGADRO","title":"<code>N_AVOGADRO = 6.02214076e+23</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.PART_DENSITY","title":"<code>PART_DENSITY = &lt;Unit('1 / meter ** 3')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.PROTON_MASS","title":"<code>PROTON_MASS = 1.67262192595e-27</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.PROTON_MOLAR_MASS","title":"<code>PROTON_MOLAR_MASS = 1.0072764676333197</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.QUANTITY","title":"<code>QUANTITY = &lt;Unit('mole')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.SIGMA_BOLTZMANN","title":"<code>SIGMA_BOLTZMANN = 5.670374419184431e-08</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.TEMP","title":"<code>TEMP = &lt;Unit('kelvin')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.TIME","title":"<code>TIME = &lt;Unit('second')&gt;</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.TYPE_CHECKING","title":"<code>TYPE_CHECKING = False</code>  <code>module-attribute</code>","text":"<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.T_MOLAR_MASS","title":"<code>T_MOLAR_MASS = 3.01604928132</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.ValueLikeT","title":"<code>ValueLikeT = ~ValueLikeT</code>  <code>module-attribute</code>","text":"<p>Type variable.</p> <p>Usage::</p> <p>T = TypeVar('T')  # Can be anything   A = TypeVar('A', str, bytes)  # Must be str or bytes</p> <p>Type variables exist primarily for the benefit of static type checkers.  They serve as the parameters for generic types as well as for generic function definitions.  See class Generic for more information on generic types.  Generic functions work as follows:</p> <p>def repeat(x: T, n: int) -&gt; List[T]:       '''Return a list containing n references to x.'''       return [x]*n</p> <p>def longest(x: A, y: A) -&gt; A:       '''Return the longest of two strings.'''       return x if len(x) &gt;= len(y) else y</p> <p>The latter example's signature is essentially the overloading of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note that if the arguments are instances of some subclass of str, the return type is still plain str.</p> <p>At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.</p> <p>Type variables defined with covariant=True or contravariant=True can be used to declare covariant or contravariant generic types. See PEP 484 for more details. By default generic types are invariant in all type variables.</p> <p>Type variables can be introspected. e.g.:</p> <p>T.name == 'T'   T.constraints == ()   T.covariant == False   T.contravariant = False   A.constraints == (str, bytes)</p> <p>Note that only type variables defined in global scope can be pickled.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.annotations","title":"<code>annotations = _Feature((3, 7, 0, 'beta', 1), None, 16777216)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.elements","title":"<code>elements = &lt;periodictable.core.PeriodicTable object at 0x7fc52abec650&gt;</code>  <code>module-attribute</code>","text":"<p>Defines the periodic table of the elements with isotopes. Individidual elements are accessed by name, symbol or atomic number. Individual isotopes are addressable by <code>element[mass_number]</code> or <code>elements.isotope(element name)</code>, <code>elements.isotope(element symbol)</code>.</p> <p>For example, the following all retrieve iron:</p> <p>.. doctest::</p> <pre><code>&gt;&gt;&gt; from periodictable import *\n&gt;&gt;&gt; print(elements[26])\nFe\n&gt;&gt;&gt; print(elements.Fe)\nFe\n&gt;&gt;&gt; print(elements.symbol('Fe'))\nFe\n&gt;&gt;&gt; print(elements.name('iron'))\nFe\n&gt;&gt;&gt; print(elements.isotope('Fe'))\nFe\n</code></pre> <p>To get iron-56, use:</p> <p>.. doctest::</p> <pre><code>&gt;&gt;&gt; print(elements[26][56])\n56-Fe\n&gt;&gt;&gt; print(elements.Fe[56])\n56-Fe\n&gt;&gt;&gt; print(elements.isotope('56-Fe'))\n56-Fe\n</code></pre> <p>Deuterium and tritium are defined as 'D' and 'T'.</p> <p>To show all the elements in the table, use the iterator:</p> <p>.. doctest::</p> <pre><code>&gt;&gt;&gt; from periodictable import *\n&gt;&gt;&gt; for el in elements:  # lists the element symbols\n...     print(\"%s %s\"%(el.symbol, el.name))  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\nH hydrogen\nHe helium\n...\nOg oganesson\n</code></pre> <p>.. Note::        Properties can be added to the elements as needed, including mass,        nuclear and X-ray scattering cross sections.        See section :ref:<code>Adding properties &lt;extending&gt;</code> for details.</p>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.TNSUnitRegistry","title":"<code>TNSUnitRegistry</code>","text":"<p>               Bases: <code>pint.registry.UnitRegistry</code></p> <p>TNS UnitRegistry Extra conversions: eV &lt;-&gt; Kelvin</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>class TNSUnitRegistry(UnitRegistry):\n    \"\"\"\n    TNS UnitRegistry\n    Extra conversions:\n    eV &lt;-&gt; Kelvin\n    \"\"\"\n\n    def __init__(self):\n        # Preprocessor replacements have spaces so\n        # the units dont become prefixes or get prefixed\n        # M$ makes sense if a bit non-standard\n        super().__init__(\n            fmt_locale=\"en_GB\",\n            preprocessors=[\n                lambda x: x.replace(\"$\", \"USD \"),\n            ],\n        )\n\n        self._contexts_added = False\n\n    def _add_contexts(self, contexts: list[Context] | None = None):\n        \"\"\"\n        Add new contexts to registry\n        \"\"\"\n        if not self._contexts_added:\n            self.contexts = [\n                self._energy_temperature_context(),\n                self._mass_energy_context(),\n            ]\n\n            for c in self.contexts:\n                self.add_context(c)\n\n            self._contexts_added = True\n\n        if contexts:\n            for c in contexts:\n                self.add_context(c)\n\n    def enable_contexts(self, *contexts: Context, **kwargs):\n        \"\"\"\n        Enable contexts\n        \"\"\"\n        self._add_contexts(contexts)\n\n        super().enable_contexts(*[*self.contexts, *contexts], **kwargs)\n\n    def _energy_temperature_context(self):\n        \"\"\"\n        Converter between energy and temperature\n        temperature = energy / k_B\n\n        Returns\n        -------\n        :\n            pint context\n        \"\"\"\n        e_to_t = Context(\"Energy_to_Temperature\")\n\n        t_units = \"[temperature]\"\n        ev_units = \"[energy]\"\n\n        conversion = self.Quantity(\"k_B\")\n\n        return self._transform(\n            e_to_t,\n            t_units,\n            ev_units,\n            lambda _, x: x * conversion,\n            lambda _, x: x / conversion,\n        )\n\n    def _mass_energy_context(self):\n        \"\"\"\n        Converter between mass and energy\n        energy = mass * speed-of-light^2\n\n        Returns\n        -------\n        :\n            pint context\n        \"\"\"\n        m_to_e = Context(\"Mass_to_Energy\")\n\n        m_units = \"[mass]\"\n        e_units = \"[energy]\"\n\n        conversion = self.Quantity(\"c^2\")\n\n        return self._transform(\n            m_to_e,\n            m_units,\n            e_units,\n            lambda _, x: x * conversion,\n            lambda _, x: x / conversion,\n        )\n\n    @staticmethod\n    def _transform(\n        context: Context,\n        units_from: str,\n        units_to: str,\n        forward_transform: Callable[[UnitRegistry, complex | Quantity], float],\n        reverse_transform: Callable[[UnitRegistry, complex | Quantity], float],\n    ) -&gt; Context:\n        formatters = [\"{}\", \"{} / [time]\"]\n\n        for form in formatters:\n            context.add_transformation(\n                form.format(units_from),\n                form.format(units_to),\n                forward_transform,\n            )\n            context.add_transformation(\n                form.format(units_to),\n                form.format(units_from),\n                reverse_transform,\n            )\n\n        return context\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.TNSUnitRegistry.enable_contexts","title":"<code>enable_contexts(*contexts, **kwargs)</code>","text":"<p>Enable contexts</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def enable_contexts(self, *contexts: Context, **kwargs):\n    \"\"\"\n    Enable contexts\n    \"\"\"\n    self._add_contexts(contexts)\n\n    super().enable_contexts(*[*self.contexts, *contexts], **kwargs)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.units_compatible","title":"<code>units_compatible(unit_1, unit_2)</code>","text":"<p>Test if units are compatible.</p> <p>Parameters:</p> Name Type Description Default <code>unit_1</code> <code>str</code> <p>unit 1 string</p> required <code>unit_2</code> <code>str</code> <p>unit 2 string</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if compatible, False otherwise</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def units_compatible(unit_1: str, unit_2: str) -&gt; bool:\n    \"\"\"\n    Test if units are compatible.\n\n    Parameters\n    ----------\n    unit_1:\n        unit 1 string\n    unit_2:\n        unit 2 string\n\n    Returns\n    -------\n    :\n        True if compatible, False otherwise\n    \"\"\"\n    try:\n        raw_uc(1, unit_1, unit_2)\n    except PintError:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/constants/#tokamak_neutron_source.constants.ureg","title":"<code>ureg(input_string, case_sensitive=None, **values)</code>","text":"<p>TNS UnitRegistry Extra conversions: eV &lt;-&gt; Kelvin</p>"},{"location":"source/reference/tokamak_neutron_source/energy/","title":"energy","text":"<p>Neutron energy spectrum calculations.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.EnergySpectrumMethod","title":"<code>EnergySpectrumMethod</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Energy spectrum calculation method.</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>class EnergySpectrumMethod(Enum):\n    \"\"\"Energy spectrum calculation method.\"\"\"\n\n    DATA = auto()\n    BALLABIO_GAUSSIAN = auto()\n    BALLABIO_M_GAUSSIAN = auto()\n    AUTO = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.EnergySpectrumMethod.AUTO","title":"<code>AUTO = &lt;EnergySpectrumMethod.AUTO: 4&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.EnergySpectrumMethod.BALLABIO_GAUSSIAN","title":"<code>BALLABIO_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_GAUSSIAN: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.EnergySpectrumMethod.BALLABIO_M_GAUSSIAN","title":"<code>BALLABIO_M_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.EnergySpectrumMethod.DATA","title":"<code>DATA = &lt;EnergySpectrumMethod.DATA: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.BallabioEnergySpectrum","title":"<code>BallabioEnergySpectrum</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>@dataclass\nclass BallabioEnergySpectrum:\n    \"\"\"\n    Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian\n    spectra.\n    \"\"\"\n\n    \"\"\"E_0\"\"\"\n    energy_0: float  # [keV]\n\n    omega_0: float  # [keV]\n\n    r\"\"\"\\Delta E_{th} coefficients\"\"\"\n    energy_shift_coeffs: BallabioCoefficients\n\n    r\"\"\"\\delta_{\\omega} coefficients\"\"\"\n    width_correction_coeffs: BallabioCoefficients\n\n    def energy_shift(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        r\"\"\"\n        Calculate the energy shift \\Delta E_{th} at a given ion temperature.\n        \"\"\"  # noqa: DOC201\n        return self.energy_shift_coeffs.fit(temp_kev)\n\n    def width_correction(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        r\"\"\"\n        Calculate the width correction \\delta_{\\omega} at a given ion temperature.\n        \"\"\"  # noqa: DOC201\n        return self.width_correction_coeffs.fit(temp_kev)\n\n    def mean_energy(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the mean neutron energy at a given ion temperature\n        (primary first moment: mu).\n        \"\"\"  # noqa: DOC201\n        return self.energy_0 + self.energy_shift(temp_kev)\n\n    def std_deviation(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the standard deviation of the neutron energy spectrum at a given ion\n        temperature (primary second moment: sigma)\n        \"\"\"  # noqa: DOC201\n        # Full width at half maximum (FWHM)\n        w_12 = self.omega_0 * (1 + self.width_correction(temp_kev)) * np.sqrt(temp_kev)\n        return w_12 / TWO_SQRT_2LN2\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.BallabioEnergySpectrum.energy_shift","title":"<code>energy_shift(temp_kev)</code>","text":"<p>Calculate the energy shift \\Delta E_{th} at a given ion temperature.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def energy_shift(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    r\"\"\"\n    Calculate the energy shift \\Delta E_{th} at a given ion temperature.\n    \"\"\"  # noqa: DOC201\n    return self.energy_shift_coeffs.fit(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.BallabioEnergySpectrum.mean_energy","title":"<code>mean_energy(temp_kev)</code>","text":"<p>Calculate the mean neutron energy at a given ion temperature (primary first moment: mu).</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def mean_energy(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the mean neutron energy at a given ion temperature\n    (primary first moment: mu).\n    \"\"\"  # noqa: DOC201\n    return self.energy_0 + self.energy_shift(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.BallabioEnergySpectrum.std_deviation","title":"<code>std_deviation(temp_kev)</code>","text":"<p>Calculate the standard deviation of the neutron energy spectrum at a given ion temperature (primary second moment: sigma)</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def std_deviation(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the standard deviation of the neutron energy spectrum at a given ion\n    temperature (primary second moment: sigma)\n    \"\"\"  # noqa: DOC201\n    # Full width at half maximum (FWHM)\n    w_12 = self.omega_0 * (1 + self.width_correction(temp_kev)) * np.sqrt(temp_kev)\n    return w_12 / TWO_SQRT_2LN2\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.BallabioEnergySpectrum.width_correction","title":"<code>width_correction(temp_kev)</code>","text":"<p>Calculate the width correction \\delta_{\\omega} at a given ion temperature.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def width_correction(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    r\"\"\"\n    Calculate the width correction \\delta_{\\omega} at a given ion temperature.\n    \"\"\"  # noqa: DOC201\n    return self.width_correction_coeffs.fit(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.EnergySpectrumError","title":"<code>EnergySpectrumError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Energy spectrum error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class EnergySpectrumError(TNSError):\n    \"\"\"Energy spectrum error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.Reactions","title":"<code>Reactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Neutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class Reactions(ReactionEnumMixin, Enum):\n    \"\"\"Neutronic reaction channels.\"\"\"\n\n    D_T = ReactionData(\n        label=\"D + T \u2192 \u2074He + n\",\n        total_energy=E_DT_FUSION,\n        num_neutrons=1,\n        cross_section=DT_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DT_4HEN,\n        ballabio_spectrum=BALLABIO_DT_NEUTRON,\n    )\n    D_D = ReactionData(\n        label=\"D + D \u2192 \u00b3He + n\",\n        total_energy=E_DD_HE3N_FUSION,\n        num_neutrons=1,\n        cross_section=DD_HE3N_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_3HEN,\n        ballabio_spectrum=BALLABIO_DD_NEUTRON,\n    )\n    T_T = ReactionData(\n        label=\"T + T \u2192 \u2074He + 2n\",\n        total_energy=E_TT_FUSION,\n        num_neutrons=2,\n        cross_section=TT_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.Reactions.D_D","title":"<code>D_D = &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.Reactions.D_T","title":"<code>D_T = &lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.Reactions.T_T","title":"<code>T_T = &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.energy_spectrum","title":"<code>energy_spectrum(temp_kev, reaction, method=&lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;)</code>","text":"<p>Calculate the tabulated energy spectrum of a reaction at a given ion temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float</code> <p>Ion temperature</p> required <code>reaction</code> <code>Reactions</code> <p>Neutronic fusion reaction</p> required <code>method</code> <code>EnergySpectrumMethod</code> <p>Method to use to calculate the energy spectrum</p> <code>&lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code> <p>Returns:</p> Name Type Description <code>energies</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>The energy bins of the probability distribution function</p> <code>pdf</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>The PDF values</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>def energy_spectrum(\n    temp_kev: float,\n    reaction: Reactions,\n    method: EnergySpectrumMethod = EnergySpectrumMethod.BALLABIO_M_GAUSSIAN,\n) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    \"\"\"\n    Calculate the tabulated energy spectrum of a reaction at a given ion temperature.\n\n    Parameters\n    ----------\n    temp_kev:\n        Ion temperature\n    reaction:\n        Neutronic fusion reaction\n    method:\n        Method to use to calculate the energy spectrum\n\n    Returns\n    -------\n    energies:\n        The energy bins of the probability distribution function\n    pdf:\n        The PDF values\n    \"\"\"\n    match method:\n        case (\n            EnergySpectrumMethod.BALLABIO_GAUSSIAN\n            | EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n        ):\n            if reaction.ballabio_spectrum is not None:\n                return _ballabio_spectrum(reaction.ballabio_spectrum, temp_kev, method)\n\n            logger.warning(\n                f\"There is no Ballabio parameterisation for reaction {reaction.name}, \"\n                \"returning energy spectrum calculated by data.\",\n                stacklevel=5,\n            )\n            return _data_spectrum(reaction, temp_kev)\n\n        case EnergySpectrumMethod.DATA:\n            return _data_spectrum(reaction, temp_kev)\n        case EnergySpectrumMethod.AUTO:\n            match reaction:\n                case Reactions.D_D | Reactions.D_T:\n                    return energy_spectrum(\n                        temp_kev, reaction, EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n                    )\n                case Reactions.T_T:\n                    return energy_spectrum(temp_kev, reaction, EnergySpectrumMethod.DATA)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy/#tokamak_neutron_source.energy.TT_N_SPECTRUM","title":"<code>TT_N_SPECTRUM(temp_kev)</code>","text":"<p>Fusion neutron energy data spectrum.</p>"},{"location":"source/reference/tokamak_neutron_source/energy_data/","title":"energy_data","text":"<p>Neutron energy spectrum data.</p>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BALLABIO_DD_NEUTRON","title":"<code>BALLABIO_DD_NEUTRON = BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946))</code>  <code>module-attribute</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BALLABIO_DT_NEUTRON","title":"<code>BALLABIO_DT_NEUTRON = BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05))</code>  <code>module-attribute</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.TWO_SQRT_2LN2","title":"<code>TWO_SQRT_2LN2 = 2.3548200450309493</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.TTNeutronEnergyDataSpectrum","title":"<code>TTNeutronEnergyDataSpectrum</code>","text":"<p>Fusion neutron energy data spectrum.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>class TTNeutronEnergyDataSpectrum:\n    \"\"\"Fusion neutron energy data spectrum.\"\"\"\n\n    def __init__(self, file_name: str):\n        \"\"\"\n        Parameters\n        ----------\n        file_name:\n            Data file\n\n        Raises\n        ------\n        EnergySpectrumError\n            Data file path is not a file\n        \"\"\"\n        path = get_tns_path(\"data/spectra\")\n        path = Path(path, file_name)\n        if not path.is_file():\n            raise EnergySpectrumError(f\"Energy spectrum data file {path} is not a file!\")\n\n        file = path.as_posix()\n        data = np.genfromtxt(file, comments=\"#\")\n\n        # The energy bins for this spectrum are hard-coded here\n        # (no sense in interpolating).\n        self._energy = raw_uc(data[:, 0], \"MeV\", \"keV\")\n\n        self._min_temp = 1.0  # [keV]\n        self._max_temp = 20.0  # [keV]\n        temperature = np.linspace(self._min_temp, self._max_temp, 40)  # [keV]\n        spectra = raw_uc(data[:, 1:], \"1/MeV\", \"1/keV\")\n        self._interpolator = RegularGridInterpolator(\n            (self._energy, temperature),\n            spectra,\n            method=\"linear\",\n            bounds_error=True,\n            fill_value=np.nan,\n        )\n\n    def __call__(self, temp_kev: float) -&gt; tuple[npt.NDArray, npt.NDArray]:\n        \"\"\"Get spectrum at a given temperature\"\"\"  # noqa: DOC201\n        if not self._min_temp &lt; temp_kev &lt; self._max_temp:\n            logger.warning(\n                f\"T-T spectral data not available at T = {temp_kev} keV, clipping back \"\n                f\"to the bounds of {self._min_temp} &lt;= T &lt;= {self._max_temp} keV\",\n                stacklevel=2,\n            )\n            temp_kev = np.clip(temp_kev, self._min_temp, self._max_temp)\n\n        return self._energy, self._interpolator((self._energy, temp_kev))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioCoefficients","title":"<code>BallabioCoefficients</code>","text":"<p>Ballabio et al. fit parameterisation coefficients for Ti &lt; 40.0 keV</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>@dataclass\nclass BallabioCoefficients:\n    \"\"\"\n    Ballabio et al. fit parameterisation coefficients for Ti &lt; 40.0 keV\n    \"\"\"\n\n    a1: float\n    a2: float\n    a3: float\n    a4: float\n\n    def fit(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the value of the parameterisation at given temperature(s).\n\n        Parameters\n        ----------\n        temp_kev:\n            Ion temperatures at which to calculate the fit\n\n        Returns\n        -------\n        :\n            Values of the fit\n\n        Notes\n        -----\n        Valid over 0.0 to 40.0 keV\n        \"\"\"\n        return (\n            self.a1 / (1 + self.a2 * temp_kev**self.a3) * temp_kev ** (2 / 3)\n            + self.a4 * temp_kev\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioCoefficients.fit","title":"<code>fit(temp_kev)</code>","text":"<p>Calculate the value of the parameterisation at given temperature(s).</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Ion temperatures at which to calculate the fit</p> required <p>Returns:</p> Type Description <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Values of the fit</p> Notes <p>Valid over 0.0 to 40.0 keV</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def fit(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the value of the parameterisation at given temperature(s).\n\n    Parameters\n    ----------\n    temp_kev:\n        Ion temperatures at which to calculate the fit\n\n    Returns\n    -------\n    :\n        Values of the fit\n\n    Notes\n    -----\n    Valid over 0.0 to 40.0 keV\n    \"\"\"\n    return (\n        self.a1 / (1 + self.a2 * temp_kev**self.a3) * temp_kev ** (2 / 3)\n        + self.a4 * temp_kev\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioEnergySpectrum","title":"<code>BallabioEnergySpectrum</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>@dataclass\nclass BallabioEnergySpectrum:\n    \"\"\"\n    Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian\n    spectra.\n    \"\"\"\n\n    \"\"\"E_0\"\"\"\n    energy_0: float  # [keV]\n\n    omega_0: float  # [keV]\n\n    r\"\"\"\\Delta E_{th} coefficients\"\"\"\n    energy_shift_coeffs: BallabioCoefficients\n\n    r\"\"\"\\delta_{\\omega} coefficients\"\"\"\n    width_correction_coeffs: BallabioCoefficients\n\n    def energy_shift(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        r\"\"\"\n        Calculate the energy shift \\Delta E_{th} at a given ion temperature.\n        \"\"\"  # noqa: DOC201\n        return self.energy_shift_coeffs.fit(temp_kev)\n\n    def width_correction(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        r\"\"\"\n        Calculate the width correction \\delta_{\\omega} at a given ion temperature.\n        \"\"\"  # noqa: DOC201\n        return self.width_correction_coeffs.fit(temp_kev)\n\n    def mean_energy(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the mean neutron energy at a given ion temperature\n        (primary first moment: mu).\n        \"\"\"  # noqa: DOC201\n        return self.energy_0 + self.energy_shift(temp_kev)\n\n    def std_deviation(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the standard deviation of the neutron energy spectrum at a given ion\n        temperature (primary second moment: sigma)\n        \"\"\"  # noqa: DOC201\n        # Full width at half maximum (FWHM)\n        w_12 = self.omega_0 * (1 + self.width_correction(temp_kev)) * np.sqrt(temp_kev)\n        return w_12 / TWO_SQRT_2LN2\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioEnergySpectrum.energy_shift","title":"<code>energy_shift(temp_kev)</code>","text":"<p>Calculate the energy shift \\Delta E_{th} at a given ion temperature.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def energy_shift(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    r\"\"\"\n    Calculate the energy shift \\Delta E_{th} at a given ion temperature.\n    \"\"\"  # noqa: DOC201\n    return self.energy_shift_coeffs.fit(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioEnergySpectrum.width_correction","title":"<code>width_correction(temp_kev)</code>","text":"<p>Calculate the width correction \\delta_{\\omega} at a given ion temperature.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def width_correction(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    r\"\"\"\n    Calculate the width correction \\delta_{\\omega} at a given ion temperature.\n    \"\"\"  # noqa: DOC201\n    return self.width_correction_coeffs.fit(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioEnergySpectrum.mean_energy","title":"<code>mean_energy(temp_kev)</code>","text":"<p>Calculate the mean neutron energy at a given ion temperature (primary first moment: mu).</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def mean_energy(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the mean neutron energy at a given ion temperature\n    (primary first moment: mu).\n    \"\"\"  # noqa: DOC201\n    return self.energy_0 + self.energy_shift(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.BallabioEnergySpectrum.std_deviation","title":"<code>std_deviation(temp_kev)</code>","text":"<p>Calculate the standard deviation of the neutron energy spectrum at a given ion temperature (primary second moment: sigma)</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def std_deviation(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the standard deviation of the neutron energy spectrum at a given ion\n    temperature (primary second moment: sigma)\n    \"\"\"  # noqa: DOC201\n    # Full width at half maximum (FWHM)\n    w_12 = self.omega_0 * (1 + self.width_correction(temp_kev)) * np.sqrt(temp_kev)\n    return w_12 / TWO_SQRT_2LN2\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.EnergySpectrumError","title":"<code>EnergySpectrumError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Energy spectrum error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class EnergySpectrumError(TNSError):\n    \"\"\"Energy spectrum error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.TT_N_SPECTRUM","title":"<code>TT_N_SPECTRUM(temp_kev)</code>","text":"<p>Fusion neutron energy data spectrum.</p>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.get_tns_path","title":"<code>get_tns_path(path='', subfolder='tokamak_neutron_source')</code>","text":"<p>Get a tns path of a module subfolder. Defaults to root folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The desired path from which to create a full path</p> <code>''</code> <code>subfolder</code> <code>str</code> <p>The subfolder (from the tokamak_neutron_source root) in which to create a path Defaults to the source code folder, but can be e.g. 'tests', or 'data'</p> <code>'tokamak_neutron_source'</code> <p>Returns:</p> Type Description <code>Path</code> <p>The full path to the desired <code>path</code> in the subfolder specified</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def get_tns_path(path: str = \"\", subfolder: str = \"tokamak_neutron_source\") -&gt; Path:\n    \"\"\"\n    Get a tns path of a module subfolder. Defaults to root folder.\n\n    Parameters\n    ----------\n    path:\n        The desired path from which to create a full path\n    subfolder:\n        The subfolder (from the tokamak_neutron_source root) in which to create a path\n        Defaults to the source code folder, but can be e.g. 'tests', or 'data'\n\n    Returns\n    -------\n    :\n        The full path to the desired `path` in the subfolder specified\n    \"\"\"\n    root = get_tns_root()\n    if \"egg\" in root:\n        return Path(f\"/{subfolder}\")\n\n    path = path.replace(\"/\", os.sep)\n    main_path = _get_relpath(root, subfolder)\n    return Path(_get_relpath(main_path, path))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/energy_data/#tokamak_neutron_source.energy_data.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/error/","title":"error","text":"<p>Error classes</p>"},{"location":"source/reference/tokamak_neutron_source/error/#tokamak_neutron_source.error.TNSError","title":"<code>TNSError</code>","text":"<p>               Bases: <code>builtins.Exception</code></p> <p>Base exception class. Sub-class from this for module level Errors.</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class TNSError(Exception):\n    \"\"\"\n    Base exception class. Sub-class from this for module level Errors.\n    \"\"\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Prettier handling of the Exception strings.\n\n        Returns\n        -------\n        :\n            The formatted exception string.\n        \"\"\"\n        return fill(dedent(self.args[0]))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/error/#tokamak_neutron_source.error.ReactivityError","title":"<code>ReactivityError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Reactivity error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class ReactivityError(TNSError):\n    \"\"\"Reactivity error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/error/#tokamak_neutron_source.error.EnergySpectrumError","title":"<code>EnergySpectrumError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Energy spectrum error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class EnergySpectrumError(TNSError):\n    \"\"\"Energy spectrum error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/error/#tokamak_neutron_source.error.FluxSurfaceError","title":"<code>FluxSurfaceError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Flux surface error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class FluxSurfaceError(TNSError):\n    \"\"\"Flux surface error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/","title":"flux","text":"<p>Flux information.</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxPoint","title":"<code>FluxPoint</code>","text":"<p>Single poloidal magnetic flux point.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@dataclass\nclass FluxPoint:\n    \"\"\"Single poloidal magnetic flux point.\"\"\"\n\n    x: float\n    z: float\n    psi: float\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ClosedFluxSurface","title":"<code>ClosedFluxSurface</code>","text":"<p>Closed poloidal magnetic flux surface.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class ClosedFluxSurface:\n    \"\"\"Closed poloidal magnetic flux surface.\"\"\"\n\n    def __init__(self, x: np.ndarray, z: np.ndarray):\n        if not is_closed(x, z):\n            raise FluxSurfaceError(\"This is not a closed flux surface.\")\n        self.x = np.asarray(x, dtype=float)\n        self.z = np.asarray(z, dtype=float)\n\n    @cached_property\n    def center_of_mass(self) -&gt; tuple[float, float]:\n        \"\"\"\n        Centre of mass of the ClosedFluxSurface.\n\n        Returns\n        -------\n        com:\n            ClosedFluxSurface center of mass\n        \"\"\"\n        return get_centroid_2d(self.x, self.z)\n\n    @cached_property\n    def area(self) -&gt; float:\n        \"\"\"\n        Enclosed area of the ClosedFluxSurface.\n\n        Returns\n        -------\n        area:\n            ClosedFluxSurface enclosed poloidal area\n        \"\"\"\n        return get_area_2d(self.x, self.z)\n\n    @cached_property\n    def volume(self) -&gt; float:\n        \"\"\"\n        Volume of the ClosedFluxSurface.\n\n        Returns\n        -------\n        volume:\n            ClosedFluxSurface enclosed volume.\n        \"\"\"\n        return 2 * np.pi * self.area * self.center_of_mass[0]\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ClosedFluxSurface.center_of_mass","title":"<code>center_of_mass</code>  <code>cached</code> <code>property</code>","text":"<p>Centre of mass of the ClosedFluxSurface.</p> <p>Returns:</p> Name Type Description <code>com</code> <code>tuple[float, float]</code> <p>ClosedFluxSurface center of mass</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ClosedFluxSurface.area","title":"<code>area</code>  <code>cached</code> <code>property</code>","text":"<p>Enclosed area of the ClosedFluxSurface.</p> <p>Returns:</p> Name Type Description <code>area</code> <code>float</code> <p>ClosedFluxSurface enclosed poloidal area</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ClosedFluxSurface.volume","title":"<code>volume</code>  <code>cached</code> <code>property</code>","text":"<p>Volume of the ClosedFluxSurface.</p> <p>Returns:</p> Name Type Description <code>volume</code> <code>float</code> <p>ClosedFluxSurface enclosed volume.</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxRing","title":"<code>FluxRing</code>","text":"<p>               Bases: <code>tokamak_neutron_source.flux.ClosedFluxSurface</code></p> <p>Flux ring.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class FluxRing(ClosedFluxSurface):\n    \"\"\"Flux ring.\"\"\"\n\n    def __init__(self, x: float, z: float):\n        self.x = np.array([x])\n        self.z = np.array([z])\n\n    @property\n    def center_of_mass(self) -&gt; tuple[float, float]:\n        \"\"\"\n        Centre of mass of the FluxRing.\n\n        Returns\n        -------\n        com:\n            FluxRing center of mass\n        \"\"\"\n        return self.x, self.z\n\n    @property\n    def area(self) -&gt; float:\n        \"\"\"\n        Enclosed area of the FluxRing.\n\n        Returns\n        -------\n        area:\n            FluxRing enclosed poloidal area\n        \"\"\"\n        return 0.0\n\n    @property\n    def volume(self) -&gt; float:\n        \"\"\"\n        Volume of the FluxRing.\n\n        Returns\n        -------\n        volume:\n            FluxRing enclosed volume.\n        \"\"\"\n        return 0.0\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxRing.area","title":"<code>area</code>  <code>property</code>","text":"<p>Enclosed area of the FluxRing.</p> <p>Returns:</p> Name Type Description <code>area</code> <p>FluxRing enclosed poloidal area</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxRing.center_of_mass","title":"<code>center_of_mass</code>  <code>property</code>","text":"<p>Centre of mass of the FluxRing.</p> <p>Returns:</p> Name Type Description <code>com</code> <p>FluxRing center of mass</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxRing.volume","title":"<code>volume</code>  <code>property</code>","text":"<p>Volume of the FluxRing.</p> <p>Returns:</p> Name Type Description <code>volume</code> <p>FluxRing enclosed volume.</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.LCFSInformation","title":"<code>LCFSInformation</code>","text":"<p>Last closed flux surface parameterisation information.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@dataclass\nclass LCFSInformation:\n    \"\"\"Last closed flux surface parameterisation information.\"\"\"\n\n    \"\"\"Plasma geometric major radius [m]\"\"\"\n    r_0: float\n\n    \"\"\"Plasma geometric vertical height [m]\"\"\"\n    z_0: float\n\n    \"\"\"Plasma geometric aspect ratio [m]\"\"\"\n    aspect_ratio: float\n\n    \"\"\"Plasma elongation\"\"\"\n    kappa: float\n\n    \"\"\"Plasma triangularity\"\"\"\n    delta: float\n\n    \"\"\"Plasma radial Shafranov shift (maximum) [m]\"\"\"\n    shafranov_shift: float\n\n    \"\"\"Plasma squareness\"\"\"\n    squareness: float = 0.0\n\n    # Derived attribute, set in __post_init__\n    minor_radius: float = field(init=False)\n\n    def __post_init__(self):\n        # --- checks ---\n        if self.r_0 &lt;= 0:\n            raise FluxSurfaceError(f\"Major radius r_0 must be &gt; 0, got {self.r_0}\")\n        if self.aspect_ratio &lt;= 1:\n            raise FluxSurfaceError(f\"Aspect ratio must be &gt; 1, got {self.aspect_ratio}\")\n        if self.kappa &lt; 1:\n            raise FluxSurfaceError(f\"Elongation kappa must be &gt;= 1, got {self.kappa}\")\n        if not -1 &lt;= self.delta &lt;= 1:\n            raise FluxSurfaceError(\n                f\"Triangularity delta must be between -1 and 1, got {self.delta}\",\n            )\n\n        self.minor_radius = self.r_0 / self.aspect_ratio\n        if abs(self.shafranov_shift) &gt;= self.minor_radius:\n            raise FluxSurfaceError(\n                f\"Shafranov shift {self.shafranov_shift} must be smaller than minor \"\n                f\"radius {self.minor_radius}\",\n            )\n        self.shafranov_shift = abs(self.shafranov_shift)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.LCFSInformation.squareness","title":"<code>squareness = 0.0</code>  <code>class-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxSurfaceParameterisation","title":"<code>FluxSurfaceParameterisation</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Abstract base class for flux surface parameterisation models.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class FluxSurfaceParameterisation(ABC):\n    \"\"\"Abstract base class for flux surface parameterisation models.\"\"\"\n\n    def __init__(self, lcfs_info: LCFSInformation):\n        self.lcfs_info = lcfs_info\n\n    def flux_surface(\n        self,\n        psi_norm: float | Iterable,\n        n_points: int = 100,\n    ) -&gt; ClosedFluxSurface | list[ClosedFluxSurface]:\n        \"\"\"\n        Return a ClosedFluxSurface for given psi_norm.\n\n        Parameters\n        ----------\n        psi_norm:\n            Normalised flux\n        n_points:\n            Number of points per flux surface\n\n        Returns\n        -------\n        flux_surface:\n            The flux surface at a given psi_norm\n        \"\"\"\n        if isinstance(psi_norm, Iterable):\n            return [self._single_flux_surface(p, n_points) for p in psi_norm]\n        return self._single_flux_surface(psi_norm, n_points)\n\n    @abstractmethod\n    def _single_flux_surface(\n        self,\n        psi_norm: float | Iterable,\n        n_points: int = 100,\n    ) -&gt; ClosedFluxSurface | list[ClosedFluxSurface]:\n        \"\"\"Return a ClosedFluxSurface for given psi_norm.\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxSurfaceParameterisation.flux_surface","title":"<code>flux_surface(psi_norm, n_points=100)</code>","text":"<p>Return a ClosedFluxSurface for given psi_norm.</p> <p>Parameters:</p> Name Type Description Default <code>psi_norm</code> <code>float | Iterable</code> <p>Normalised flux</p> required <code>n_points</code> <code>int</code> <p>Number of points per flux surface</p> <code>100</code> <p>Returns:</p> Name Type Description <code>flux_surface</code> <code>ClosedFluxSurface | list[ClosedFluxSurface]</code> <p>The flux surface at a given psi_norm</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def flux_surface(\n    self,\n    psi_norm: float | Iterable,\n    n_points: int = 100,\n) -&gt; ClosedFluxSurface | list[ClosedFluxSurface]:\n    \"\"\"\n    Return a ClosedFluxSurface for given psi_norm.\n\n    Parameters\n    ----------\n    psi_norm:\n        Normalised flux\n    n_points:\n        Number of points per flux surface\n\n    Returns\n    -------\n    flux_surface:\n        The flux surface at a given psi_norm\n    \"\"\"\n    if isinstance(psi_norm, Iterable):\n        return [self._single_flux_surface(p, n_points) for p in psi_norm]\n    return self._single_flux_surface(psi_norm, n_points)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FausserFluxSurface","title":"<code>FausserFluxSurface</code>","text":"<p>               Bases: <code>tokamak_neutron_source.flux.FluxSurfaceParameterisation</code></p> <p>Fausser et al. flux surface parameterisation.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class FausserFluxSurface(FluxSurfaceParameterisation):\n    \"\"\"Fausser et al. flux surface parameterisation.\"\"\"\n\n    def _single_flux_surface(\n        self,\n        psi_norm: float,\n        n_points: int = 100,\n    ) -&gt; ClosedFluxSurface:\n        a = psi_norm * self.lcfs_info.r_0 / self.lcfs_info.aspect_ratio\n        alpha = np.linspace(0, 2 * np.pi, n_points)\n        r = (\n            self.lcfs_info.r_0\n            + a * np.cos(alpha + self.lcfs_info.delta * np.sin(alpha))\n            + abs(self.lcfs_info.shafranov_shift) * (1 - psi_norm**2)\n        )\n        z = self.lcfs_info.z_0 + a * self.lcfs_info.kappa * np.sin(alpha)\n        return ClosedFluxSurface(r, z)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.SauterFluxSurface","title":"<code>SauterFluxSurface</code>","text":"<p>               Bases: <code>tokamak_neutron_source.flux.FluxSurfaceParameterisation</code></p> <p>Sauter et al. flux surface parameterisation.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class SauterFluxSurface(FluxSurfaceParameterisation):\n    \"\"\"Sauter et al. flux surface parameterisation.\"\"\"\n\n    def _single_flux_surface(self, psi_norm, n_points=100):\n        a = psi_norm * self.lcfs_info.minor_radius\n        alpha = np.linspace(0, 2 * np.pi, n_points)\n        r = (\n            self.lcfs_info.r_0\n            + a * np.cos(alpha + self.lcfs_info.delta * np.sin(alpha))\n            - self.lcfs_info.squareness * np.sin(2 * alpha)\n        )\n        z = self.lcfs_info.z_0 + self.lcfs_info.kappa * a * np.sin(\n            alpha + self.lcfs_info.squareness * np.sin(2 * alpha)\n        )\n        return ClosedFluxSurface(r, z)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxConvention","title":"<code>FluxConvention</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Flux normalisation convention.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class FluxConvention(Enum):\n    \"\"\"Flux normalisation convention.\"\"\"\n\n    \"\"\"Linear flux normalisation\"\"\"\n    LINEAR = auto()\n\n    \"\"\"Square-root flux normalisation\"\"\"\n    SQRT = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxConvention.LINEAR","title":"<code>LINEAR = &lt;FluxConvention.LINEAR: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Flux normalisation convention.</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxConvention.SQRT","title":"<code>SQRT = &lt;FluxConvention.SQRT: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Flux normalisation convention.</p>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxInterpolator","title":"<code>FluxInterpolator</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Abstract base class for FluxInterpolators.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class FluxInterpolator(ABC):\n    \"\"\"Abstract base class for FluxInterpolators.\"\"\"\n\n    def __init__(\n        self,\n        x: npt.NDArray,\n        z: npt.NDArray,\n        psi_norm: npt.NDArray,\n        o_point: FluxPoint,\n    ):\n        self.x = x\n        self.z = z\n        self._psi_norm = psi_norm\n        self._o_point = o_point\n\n    @abstractmethod\n    def psi_norm(self, x: float, z: float) -&gt; float:\n        \"\"\"\n        Get the normalised flux at a given point.\n\n        Parameters\n        ----------\n        x:\n            Radial coordinate\n        z:\n            Vertical coordinate\n\n        Returns\n        -------\n        psi_norm:\n            Normalised flux at the point\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_flux_surface(\n        self,\n        psi_norm: float,\n        n_points: int | None = None,\n    ) -&gt; ClosedFluxSurface:\n        \"\"\"\n        Get a flux surface at a given normalised flux.\n\n        Parameters\n        ----------\n        psi_norm:\n            Normalised flux\n\n        Returns\n        -------\n        flux_surface:\n            Flux surface at the normalised flux\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def plot_normalised_flux(\n        self,\n        ax: plt.Axes,\n        levels: np.ndarray | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"\n        Plot the normalised flux.\n\n        Parameters\n        ----------\n        ax:\n            matplotlib Axes object to use\n        levels:\n            Normalised psi contour levels to plot\n\n        Returns\n        -------\n        ax:\n            updated matplotlib Axes\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxInterpolator.psi_norm","title":"<code>psi_norm(x, z)</code>","text":"<p>Get the normalised flux at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Radial coordinate</p> required <code>z</code> <code>float</code> <p>Vertical coordinate</p> required <p>Returns:</p> Name Type Description <code>psi_norm</code> <code>float</code> <p>Normalised flux at the point</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@abstractmethod\ndef psi_norm(self, x: float, z: float) -&gt; float:\n    \"\"\"\n    Get the normalised flux at a given point.\n\n    Parameters\n    ----------\n    x:\n        Radial coordinate\n    z:\n        Vertical coordinate\n\n    Returns\n    -------\n    psi_norm:\n        Normalised flux at the point\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxInterpolator.get_flux_surface","title":"<code>get_flux_surface(psi_norm, n_points=None)</code>","text":"<p>Get a flux surface at a given normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>psi_norm</code> <code>float</code> <p>Normalised flux</p> required <p>Returns:</p> Name Type Description <code>flux_surface</code> <code>ClosedFluxSurface</code> <p>Flux surface at the normalised flux</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@abstractmethod\ndef get_flux_surface(\n    self,\n    psi_norm: float,\n    n_points: int | None = None,\n) -&gt; ClosedFluxSurface:\n    \"\"\"\n    Get a flux surface at a given normalised flux.\n\n    Parameters\n    ----------\n    psi_norm:\n        Normalised flux\n\n    Returns\n    -------\n    flux_surface:\n        Flux surface at the normalised flux\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxInterpolator.plot_normalised_flux","title":"<code>plot_normalised_flux(ax, levels=None)</code>","text":"<p>Plot the normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib Axes object to use</p> required <code>levels</code> <code>ndarray | None</code> <p>Normalised psi contour levels to plot</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code> <p>updated matplotlib Axes</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@abstractmethod\ndef plot_normalised_flux(\n    self,\n    ax: plt.Axes,\n    levels: np.ndarray | None = None,\n) -&gt; plt.Axes:\n    \"\"\"\n    Plot the normalised flux.\n\n    Parameters\n    ----------\n    ax:\n        matplotlib Axes object to use\n    levels:\n        Normalised psi contour levels to plot\n\n    Returns\n    -------\n    ax:\n        updated matplotlib Axes\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.EQDSKFluxInterpolator","title":"<code>EQDSKFluxInterpolator</code>","text":"<p>               Bases: <code>tokamak_neutron_source.flux.FluxInterpolator</code></p> <p>EQDSK FluxInterpolator.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class EQDSKFluxInterpolator(FluxInterpolator):\n    \"\"\"EQDSK FluxInterpolator.\"\"\"\n\n    def __init__(\n        self,\n        x: npt.NDArray,\n        z: npt.NDArray,\n        psi_norm: npt.NDArray,\n        o_point: FluxPoint,\n    ):\n        super().__init__(x, z, psi_norm, o_point)\n        self._psi_norm_func = RectBivariateSpline(\n            self.x[:, 0],\n            self.z[0, :],\n            self._psi_norm,\n        )\n\n    def psi_norm(self, x: float, z: float) -&gt; float:\n        \"\"\"\n        Get the normalised flux at a given point.\n\n        Parameters\n        ----------\n        x:\n            Radial coordinate\n        z:\n            Vertical coordinate\n\n        Returns\n        -------\n        psi_norm:\n            Normalised flux at the point\n        \"\"\"\n        return self._psi_norm_func(x, z, grid=False)\n\n    def get_flux_surface(\n        self,\n        psi_norm: float,\n        n_points: int | None = None,\n    ) -&gt; ClosedFluxSurface:\n        \"\"\"\n        Get a flux surface at a given normalised flux.\n\n        Parameters\n        ----------\n        psi_norm:\n            Normalised flux\n\n        Returns\n        -------\n        flux_surface:\n            Flux surface at the normalised flux\n        \"\"\"\n        psi_norm = np.clip(psi_norm, 0.0, 1.0)\n        if psi_norm == 0.0:\n            return FluxRing(self._o_point.x, self._o_point.z)\n\n        x, z = find_flux_surf(self.x, self.z, self._psi_norm, psi_norm, self._o_point)\n        if n_points is None:\n            return ClosedFluxSurface(x, z)\n        return ClosedFluxSurface(*interpolate_flux_surface(x, z, n_points))\n\n    def plot_normalised_flux(\n        self,\n        ax: plt.Axes,\n        levels: npt.NDArray | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"\n        Plot the normalised flux.\n\n        Parameters\n        ----------\n        ax:\n            matplotlib Axes object to use\n        levels:\n            Normalised psi contour levels to plot\n\n        Returns\n        -------\n        ax:\n            updated matplotlib Axes\n        \"\"\"\n        if levels is None:\n            levels = np.linspace(0, 1, 10)\n        ax.contour(self.x, self.z, self._psi_norm, levels=levels, cmap=\"viridis\")\n        ax.plot(self._o_point.x, self._o_point.z, marker=\"o\", color=\"b\")\n        return ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.EQDSKFluxInterpolator.psi_norm","title":"<code>psi_norm(x, z)</code>","text":"<p>Get the normalised flux at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Radial coordinate</p> required <code>z</code> <code>float</code> <p>Vertical coordinate</p> required <p>Returns:</p> Name Type Description <code>psi_norm</code> <code>float</code> <p>Normalised flux at the point</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def psi_norm(self, x: float, z: float) -&gt; float:\n    \"\"\"\n    Get the normalised flux at a given point.\n\n    Parameters\n    ----------\n    x:\n        Radial coordinate\n    z:\n        Vertical coordinate\n\n    Returns\n    -------\n    psi_norm:\n        Normalised flux at the point\n    \"\"\"\n    return self._psi_norm_func(x, z, grid=False)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.EQDSKFluxInterpolator.get_flux_surface","title":"<code>get_flux_surface(psi_norm, n_points=None)</code>","text":"<p>Get a flux surface at a given normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>psi_norm</code> <code>float</code> <p>Normalised flux</p> required <p>Returns:</p> Name Type Description <code>flux_surface</code> <code>ClosedFluxSurface</code> <p>Flux surface at the normalised flux</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def get_flux_surface(\n    self,\n    psi_norm: float,\n    n_points: int | None = None,\n) -&gt; ClosedFluxSurface:\n    \"\"\"\n    Get a flux surface at a given normalised flux.\n\n    Parameters\n    ----------\n    psi_norm:\n        Normalised flux\n\n    Returns\n    -------\n    flux_surface:\n        Flux surface at the normalised flux\n    \"\"\"\n    psi_norm = np.clip(psi_norm, 0.0, 1.0)\n    if psi_norm == 0.0:\n        return FluxRing(self._o_point.x, self._o_point.z)\n\n    x, z = find_flux_surf(self.x, self.z, self._psi_norm, psi_norm, self._o_point)\n    if n_points is None:\n        return ClosedFluxSurface(x, z)\n    return ClosedFluxSurface(*interpolate_flux_surface(x, z, n_points))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.EQDSKFluxInterpolator.plot_normalised_flux","title":"<code>plot_normalised_flux(ax, levels=None)</code>","text":"<p>Plot the normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib Axes object to use</p> required <code>levels</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]] | None</code> <p>Normalised psi contour levels to plot</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ax</code> <code>Axes</code> <p>updated matplotlib Axes</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def plot_normalised_flux(\n    self,\n    ax: plt.Axes,\n    levels: npt.NDArray | None = None,\n) -&gt; plt.Axes:\n    \"\"\"\n    Plot the normalised flux.\n\n    Parameters\n    ----------\n    ax:\n        matplotlib Axes object to use\n    levels:\n        Normalised psi contour levels to plot\n\n    Returns\n    -------\n    ax:\n        updated matplotlib Axes\n    \"\"\"\n    if levels is None:\n        levels = np.linspace(0, 1, 10)\n    ax.contour(self.x, self.z, self._psi_norm, levels=levels, cmap=\"viridis\")\n    ax.plot(self._o_point.x, self._o_point.z, marker=\"o\", color=\"b\")\n    return ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ParameterisationInterpolator","title":"<code>ParameterisationInterpolator</code>","text":"<p>               Bases: <code>tokamak_neutron_source.flux.FluxInterpolator</code></p> <p>FluxInterpolator from a flux surface parameterisation.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class ParameterisationInterpolator(FluxInterpolator):\n    \"\"\"FluxInterpolator from a flux surface parameterisation.\"\"\"\n\n    def __init__(\n        self,\n        parameterisation: FluxSurfaceParameterisation,\n        o_point: FluxPoint,\n        rho_profile: np.ndarray,\n        n_points: int,\n        flux_convention: FluxConvention = FluxConvention.LINEAR,\n    ):\n        self._parameterisation = parameterisation\n        self._n_points = n_points\n\n        # Treat the core differently\n        rho_profile = rho_profile[rho_profile &gt; 0.0]\n\n        flux_surfaces = self._parameterisation.flux_surface(rho_profile, self._n_points)\n\n        x = np.concatenate([f.x for f in flux_surfaces])\n        z = np.concatenate([f.z for f in flux_surfaces])\n\n        psi = np.concatenate([[1 - rho] * n_points for rho in rho_profile])\n\n        # Add the core\n        x = np.concatenate([x, [o_point.x]])\n        z = np.concatenate([z, [o_point.z]])\n        psi = np.concatenate([psi, [o_point.psi]])\n\n        psi_norm = normalise_psi(psi, o_point.psi, 0.0, flux_convention)\n        super().__init__(x, z, psi_norm, o_point)\n        self._psi_norm_func = CloughTocher2DInterpolator(\n            np.column_stack((x, z)),\n            psi_norm,\n            fill_value=1.0,\n        )\n\n    def psi_norm(self, x: float, z: float) -&gt; float:\n        \"\"\"\n        Get the normalised flux at a given point.\n\n        Parameters\n        ----------\n        x:\n            Radial coordinate\n        z:\n            Vertical coordinate\n\n        Returns\n        -------\n        psi_norm:\n            Normalised flux at the point\n        \"\"\"\n        return self._psi_norm_func(x, z)\n\n    def get_flux_surface(\n        self,\n        psi_norm: float,\n        n_points: int | None = None,\n    ) -&gt; ClosedFluxSurface:\n        \"\"\"\n        Get a flux surface at a given normalised flux.\n\n        Parameters\n        ----------\n        psi_norm:\n            Normalised flux\n\n        Returns\n        -------\n        flux_surface:\n            Flux surface at the normalised flux\n        \"\"\"\n        if n_points is None:\n            n_points = self._n_points\n        return self._parameterisation.flux_surface(psi_norm, n_points)\n\n    def plot_normalised_flux(\n        self,\n        ax: plt.Axes,\n        levels: npt.NDArray | None = None,\n    ) -&gt; plt.Axes:\n        ax.tricontour(self.x, self.z, self._psi_norm, levels=levels)\n        return ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ParameterisationInterpolator.psi_norm","title":"<code>psi_norm(x, z)</code>","text":"<p>Get the normalised flux at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Radial coordinate</p> required <code>z</code> <code>float</code> <p>Vertical coordinate</p> required <p>Returns:</p> Name Type Description <code>psi_norm</code> <code>float</code> <p>Normalised flux at the point</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def psi_norm(self, x: float, z: float) -&gt; float:\n    \"\"\"\n    Get the normalised flux at a given point.\n\n    Parameters\n    ----------\n    x:\n        Radial coordinate\n    z:\n        Vertical coordinate\n\n    Returns\n    -------\n    psi_norm:\n        Normalised flux at the point\n    \"\"\"\n    return self._psi_norm_func(x, z)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ParameterisationInterpolator.get_flux_surface","title":"<code>get_flux_surface(psi_norm, n_points=None)</code>","text":"<p>Get a flux surface at a given normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>psi_norm</code> <code>float</code> <p>Normalised flux</p> required <p>Returns:</p> Name Type Description <code>flux_surface</code> <code>ClosedFluxSurface</code> <p>Flux surface at the normalised flux</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def get_flux_surface(\n    self,\n    psi_norm: float,\n    n_points: int | None = None,\n) -&gt; ClosedFluxSurface:\n    \"\"\"\n    Get a flux surface at a given normalised flux.\n\n    Parameters\n    ----------\n    psi_norm:\n        Normalised flux\n\n    Returns\n    -------\n    flux_surface:\n        Flux surface at the normalised flux\n    \"\"\"\n    if n_points is None:\n        n_points = self._n_points\n    return self._parameterisation.flux_surface(psi_norm, n_points)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.ParameterisationInterpolator.plot_normalised_flux","title":"<code>plot_normalised_flux(ax, levels=None)</code>","text":"Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def plot_normalised_flux(\n    self,\n    ax: plt.Axes,\n    levels: npt.NDArray | None = None,\n) -&gt; plt.Axes:\n    ax.tricontour(self.x, self.z, self._psi_norm, levels=levels)\n    return ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap","title":"<code>FluxMap</code>","text":"<p>Magneto-hydrodynamic equilibrium poloidal magnetic flux map.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@dataclass\nclass FluxMap:\n    \"\"\"Magneto-hydrodynamic equilibrium poloidal magnetic flux map.\"\"\"\n\n    \"\"\"Last closed flux surface\"\"\"\n    lcfs: ClosedFluxSurface\n\n    \"\"\"Magnetic axis point\"\"\"\n    o_point: FluxPoint\n\n    \"\"\"Flux interpolator object\"\"\"\n    interpolator: FluxInterpolator\n\n    @classmethod\n    def from_eqdsk(\n        cls,\n        file_name: str | EQDSKInterface,\n        flux_convention: FluxConvention = FluxConvention.LINEAR,\n    ):\n        \"\"\"\n        Initialise a FluxMap from an EQDSK.\n\n        Parameters\n        ----------\n        file_name:\n            EQDSK file name (or the EQDSKInterface)\n        flux_convention:\n            Flux normalisation convention\n\n        Returns\n        -------\n        flux_map:\n            FluxMap from the EQDSK\n        \"\"\"\n        eq = load_eqdsk(file_name)\n        x, z = np.meshgrid(eq.x, eq.z, indexing=\"ij\")\n\n        lcfs = ClosedFluxSurface(eq.xbdry, eq.zbdry)\n        o_point = FluxPoint(eq.xmag, eq.zmag, eq.psimag)\n        # This is for the case where an Equilibrium is provided via EQDSK,\n        # and we assume that the provided LCFS is \"true\".\n        psi_func = RectBivariateSpline(\n            x[:, 0],\n            z[0, :],\n            eq.psi,\n        )\n        # We renormalise our interpolated psi to match the LCFS in the\n        # EQDSK. This will ensure that the reconstructed LCFS is\n        # almost perfectly indentical (and still closed).\n        boundary_psi = np.min(psi_func(lcfs.x, lcfs.z, grid=False))\n        psi_norm = normalise_psi(eq.psi, eq.psimag, boundary_psi, flux_convention)\n        interpolator = EQDSKFluxInterpolator(x, z, psi_norm, o_point)\n\n        return cls(lcfs, o_point, interpolator)\n\n    @classmethod\n    def from_parameterisation(\n        cls,\n        parameterisation: FluxSurfaceParameterisation,\n        rho_profile: np.ndarray,\n        n_points: int = 100,\n        flux_convention: FluxConvention = FluxConvention.LINEAR,\n    ):\n        \"\"\"\n        Initialise a FluxMap from a FluxSurfaceParameterisation.\n\n        Parameters\n        ----------\n        parameterisation:\n            FluxSurfaceParameteristion to use\n        rho_profile:\n            Normalised radius array to use\n        n_points:\n            Number of points per flux surface\n        flux_convention:\n            Flux normalisation convention\n\n        Returns\n        -------\n        flux_map:\n            FluxMap from the parameterisation\n        \"\"\"\n        lcfs = parameterisation.flux_surface(1.0, n_points)\n        o_point = FluxPoint(\n            parameterisation.lcfs_info.r_0 + parameterisation.lcfs_info.shafranov_shift,\n            0.0,\n            1.0,\n        )\n        interpolator = ParameterisationInterpolator(\n            parameterisation,\n            o_point,\n            rho_profile,\n            n_points,\n            flux_convention,\n        )\n        return cls(lcfs, o_point, interpolator)\n\n    def psi_norm(self, x: float, z: float) -&gt; float:\n        \"\"\"\n        Get the normalised flux at a given point.\n\n        Parameters\n        ----------\n        x:\n            Radial coordinate\n        z:\n            Vertical coordinate\n\n        Returns\n        -------\n        psi_norm:\n            Normalised flux at the point\n        \"\"\"\n        return self.interpolator.psi_norm(x, z)\n\n    def get_flux_surface(\n        self,\n        psi_norm: float,\n        n_points: int | None = None,\n    ) -&gt; ClosedFluxSurface | list[ClosedFluxSurface]:\n        \"\"\"\n        Get a flux surface at a given normalised flux.\n\n        Parameters\n        ----------\n        psi_norm:\n            Normalised flux\n\n        Returns\n        -------\n        flux_surface:\n            Flux surface at the normalised flux\n        \"\"\"\n        if isinstance(psi_norm, Iterable):\n            return [self.interpolator.get_flux_surface(p, n_points) for p in psi_norm]\n        return self.interpolator.get_flux_surface(psi_norm, n_points)\n\n    def volume(self, psi_norm: float) -&gt; float | list[float]:\n        \"\"\"\n        Get the volume at a given normalised flux.\n\n        Parameters\n        ----------\n        psi_norm:\n            Normalised flux\n\n        Returns\n        -------\n        volume:\n            Volume at the normalised flux\n        \"\"\"\n        fs = self.get_flux_surface(psi_norm)\n        if isinstance(fs, Iterable):\n            return [s.volume for s in fs]\n        return fs.volume\n\n    def plot(\n        self,\n        f: plt.Figure | None = None,\n        ax: plt.Axes | None = None,\n        levels: npt.NDArray | None = None,\n    ) -&gt; tuple[plt.Figure, plt.Axes]:\n        \"\"\"\n        Plot the FluxMap.\n\n        Parameters\n        ----------\n        f:\n            Matplotlib figure\n        ax:\n            Matplotlib axes\n        levels:\n            Normalised psi contour levels to plot\n\n        Returns\n        -------\n        f:\n            Matplotlib figure\n        ax:\n            Matplotlib axes\n        \"\"\"\n        if ax is None:\n            f, ax = plt.subplots()\n        if f is None:\n            f = ax.get_figure()\n        self.interpolator.plot_normalised_flux(ax, levels=levels)\n        ax.plot(self.lcfs.x, self.lcfs.z, color=\"r\", lw=2)\n        ax.set_xlabel(\"x [m]\")\n        ax.set_ylabel(\"z [m]\")\n        ax.set_aspect(\"equal\")\n        return f, ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap.from_eqdsk","title":"<code>from_eqdsk(file_name, flux_convention=&lt;FluxConvention.LINEAR: 1&gt;)</code>  <code>classmethod</code>","text":"<p>Initialise a FluxMap from an EQDSK.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str | EQDSKInterface</code> <p>EQDSK file name (or the EQDSKInterface)</p> required <code>flux_convention</code> <code>FluxConvention</code> <p>Flux normalisation convention</p> <code>&lt;FluxConvention.LINEAR: 1&gt;</code> <p>Returns:</p> Name Type Description <code>flux_map</code> <p>FluxMap from the EQDSK</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@classmethod\ndef from_eqdsk(\n    cls,\n    file_name: str | EQDSKInterface,\n    flux_convention: FluxConvention = FluxConvention.LINEAR,\n):\n    \"\"\"\n    Initialise a FluxMap from an EQDSK.\n\n    Parameters\n    ----------\n    file_name:\n        EQDSK file name (or the EQDSKInterface)\n    flux_convention:\n        Flux normalisation convention\n\n    Returns\n    -------\n    flux_map:\n        FluxMap from the EQDSK\n    \"\"\"\n    eq = load_eqdsk(file_name)\n    x, z = np.meshgrid(eq.x, eq.z, indexing=\"ij\")\n\n    lcfs = ClosedFluxSurface(eq.xbdry, eq.zbdry)\n    o_point = FluxPoint(eq.xmag, eq.zmag, eq.psimag)\n    # This is for the case where an Equilibrium is provided via EQDSK,\n    # and we assume that the provided LCFS is \"true\".\n    psi_func = RectBivariateSpline(\n        x[:, 0],\n        z[0, :],\n        eq.psi,\n    )\n    # We renormalise our interpolated psi to match the LCFS in the\n    # EQDSK. This will ensure that the reconstructed LCFS is\n    # almost perfectly indentical (and still closed).\n    boundary_psi = np.min(psi_func(lcfs.x, lcfs.z, grid=False))\n    psi_norm = normalise_psi(eq.psi, eq.psimag, boundary_psi, flux_convention)\n    interpolator = EQDSKFluxInterpolator(x, z, psi_norm, o_point)\n\n    return cls(lcfs, o_point, interpolator)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap.from_parameterisation","title":"<code>from_parameterisation(parameterisation, rho_profile, n_points=100, flux_convention=&lt;FluxConvention.LINEAR: 1&gt;)</code>  <code>classmethod</code>","text":"<p>Initialise a FluxMap from a FluxSurfaceParameterisation.</p> <p>Parameters:</p> Name Type Description Default <code>parameterisation</code> <code>FluxSurfaceParameterisation</code> <p>FluxSurfaceParameteristion to use</p> required <code>rho_profile</code> <code>ndarray</code> <p>Normalised radius array to use</p> required <code>n_points</code> <code>int</code> <p>Number of points per flux surface</p> <code>100</code> <code>flux_convention</code> <code>FluxConvention</code> <p>Flux normalisation convention</p> <code>&lt;FluxConvention.LINEAR: 1&gt;</code> <p>Returns:</p> Name Type Description <code>flux_map</code> <p>FluxMap from the parameterisation</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@classmethod\ndef from_parameterisation(\n    cls,\n    parameterisation: FluxSurfaceParameterisation,\n    rho_profile: np.ndarray,\n    n_points: int = 100,\n    flux_convention: FluxConvention = FluxConvention.LINEAR,\n):\n    \"\"\"\n    Initialise a FluxMap from a FluxSurfaceParameterisation.\n\n    Parameters\n    ----------\n    parameterisation:\n        FluxSurfaceParameteristion to use\n    rho_profile:\n        Normalised radius array to use\n    n_points:\n        Number of points per flux surface\n    flux_convention:\n        Flux normalisation convention\n\n    Returns\n    -------\n    flux_map:\n        FluxMap from the parameterisation\n    \"\"\"\n    lcfs = parameterisation.flux_surface(1.0, n_points)\n    o_point = FluxPoint(\n        parameterisation.lcfs_info.r_0 + parameterisation.lcfs_info.shafranov_shift,\n        0.0,\n        1.0,\n    )\n    interpolator = ParameterisationInterpolator(\n        parameterisation,\n        o_point,\n        rho_profile,\n        n_points,\n        flux_convention,\n    )\n    return cls(lcfs, o_point, interpolator)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap.psi_norm","title":"<code>psi_norm(x, z)</code>","text":"<p>Get the normalised flux at a given point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Radial coordinate</p> required <code>z</code> <code>float</code> <p>Vertical coordinate</p> required <p>Returns:</p> Name Type Description <code>psi_norm</code> <code>float</code> <p>Normalised flux at the point</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def psi_norm(self, x: float, z: float) -&gt; float:\n    \"\"\"\n    Get the normalised flux at a given point.\n\n    Parameters\n    ----------\n    x:\n        Radial coordinate\n    z:\n        Vertical coordinate\n\n    Returns\n    -------\n    psi_norm:\n        Normalised flux at the point\n    \"\"\"\n    return self.interpolator.psi_norm(x, z)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap.get_flux_surface","title":"<code>get_flux_surface(psi_norm, n_points=None)</code>","text":"<p>Get a flux surface at a given normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>psi_norm</code> <code>float</code> <p>Normalised flux</p> required <p>Returns:</p> Name Type Description <code>flux_surface</code> <code>ClosedFluxSurface | list[ClosedFluxSurface]</code> <p>Flux surface at the normalised flux</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def get_flux_surface(\n    self,\n    psi_norm: float,\n    n_points: int | None = None,\n) -&gt; ClosedFluxSurface | list[ClosedFluxSurface]:\n    \"\"\"\n    Get a flux surface at a given normalised flux.\n\n    Parameters\n    ----------\n    psi_norm:\n        Normalised flux\n\n    Returns\n    -------\n    flux_surface:\n        Flux surface at the normalised flux\n    \"\"\"\n    if isinstance(psi_norm, Iterable):\n        return [self.interpolator.get_flux_surface(p, n_points) for p in psi_norm]\n    return self.interpolator.get_flux_surface(psi_norm, n_points)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap.volume","title":"<code>volume(psi_norm)</code>","text":"<p>Get the volume at a given normalised flux.</p> <p>Parameters:</p> Name Type Description Default <code>psi_norm</code> <code>float</code> <p>Normalised flux</p> required <p>Returns:</p> Name Type Description <code>volume</code> <code>float | list[float]</code> <p>Volume at the normalised flux</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def volume(self, psi_norm: float) -&gt; float | list[float]:\n    \"\"\"\n    Get the volume at a given normalised flux.\n\n    Parameters\n    ----------\n    psi_norm:\n        Normalised flux\n\n    Returns\n    -------\n    volume:\n        Volume at the normalised flux\n    \"\"\"\n    fs = self.get_flux_surface(psi_norm)\n    if isinstance(fs, Iterable):\n        return [s.volume for s in fs]\n    return fs.volume\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxMap.plot","title":"<code>plot(f=None, ax=None, levels=None)</code>","text":"<p>Plot the FluxMap.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Figure | None</code> <p>Matplotlib figure</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>Matplotlib axes</p> <code>None</code> <code>levels</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]] | None</code> <p>Normalised psi contour levels to plot</p> <code>None</code> <p>Returns:</p> Name Type Description <code>f</code> <code>Figure</code> <p>Matplotlib figure</p> <code>ax</code> <code>Axes</code> <p>Matplotlib axes</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def plot(\n    self,\n    f: plt.Figure | None = None,\n    ax: plt.Axes | None = None,\n    levels: npt.NDArray | None = None,\n) -&gt; tuple[plt.Figure, plt.Axes]:\n    \"\"\"\n    Plot the FluxMap.\n\n    Parameters\n    ----------\n    f:\n        Matplotlib figure\n    ax:\n        Matplotlib axes\n    levels:\n        Normalised psi contour levels to plot\n\n    Returns\n    -------\n    f:\n        Matplotlib figure\n    ax:\n        Matplotlib axes\n    \"\"\"\n    if ax is None:\n        f, ax = plt.subplots()\n    if f is None:\n        f = ax.get_figure()\n    self.interpolator.plot_normalised_flux(ax, levels=levels)\n    ax.plot(self.lcfs.x, self.lcfs.z, color=\"r\", lw=2)\n    ax.set_xlabel(\"x [m]\")\n    ax.set_ylabel(\"z [m]\")\n    ax.set_aspect(\"equal\")\n    return f, ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.FluxSurfaceError","title":"<code>FluxSurfaceError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Flux surface error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class FluxSurfaceError(TNSError):\n    \"\"\"Flux surface error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.is_closed","title":"<code>is_closed(x, z, abs_tol=1e-12)</code>","text":"Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def is_closed(x: np.ndarray, z: np.ndarray, abs_tol: float = 1e-12) -&gt; bool:\n    return np.isclose(x[0], x[-1], rtol=0.0, atol=abs_tol) and np.isclose(\n        z[0],\n        z[-1],\n        rtol=0.0,\n        atol=abs_tol,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.get_contours","title":"<code>get_contours(x, z, array, value)</code>","text":"<p>Get the contours of a value in continuous array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The x value array</p> required <code>z</code> <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The z value array</p> required <code>array</code> <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The value array</p> required <code>value</code> <code>float</code> <p>The value of the desired contour in the array</p> required <p>Returns:</p> Type Description <code>list[ndarray[tuple[Any, ...], dtype[float64]]]</code> <p>The list of arrays of value contour(s) in the array</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def get_contours(\n    x: npt.NDArray[np.float64],\n    z: npt.NDArray[np.float64],\n    array: npt.NDArray[np.float64],\n    value: float,\n) -&gt; list[npt.NDArray[np.float64]]:\n    \"\"\"\n    Get the contours of a value in continuous array.\n\n    Parameters\n    ----------\n    x:\n        The x value array\n    z:\n        The z value array\n    array:\n        The value array\n    value: f\n        The value of the desired contour in the array\n\n    Returns\n    -------\n    :\n        The list of arrays of value contour(s) in the array\n    \"\"\"\n    con_gen = contour_generator(\n        x,\n        z,\n        array,\n        name=\"mpl2014\",\n        line_type=LineType.SeparateCode,\n    )\n    return con_gen.lines(value)[0]\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.find_flux_surf","title":"<code>find_flux_surf(x, z, psi_norm, psi_norm_value, o_point)</code>","text":"<p>Picks a flux surface with a normalised psi norm relative to the separatrix. Uses least squares to retain only the most appropriate flux surface. This is taken to be the surface whose geometric centre is closest to the O-point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The spatial x coordinates of the grid points [m]</p> required <code>z</code> <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The spatial z coordinates of the grid points [m]</p> required <code>psi_norm</code> <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The normalised poloidal magnetic flux map [-]</p> required <code>psi_norm_value</code> <code>float</code> <p>The normalised psi value of the desired flux surface [-]</p> required <code>o_point</code> <code>FluxPoint</code> <p>O-points to use to calculate psinorm</p> required <p>Returns:</p> Type Description <code>ndarray[tuple[Any, ...], dtype[float64]]</code> <p>The flux surface coordinate array</p> <p>Raises:</p> Type Description <code>FluxSurfaceError</code> <p>No flux surface found at psi_norm</p> Notes <p>\\t:math:<code>{\\\\Psi}_{N} = {\\\\psi}_{O}-N({\\\\psi}_{O}-{\\\\psi}_{X})</code></p> <p>Uses matplotlib hacks to pick contour surfaces on psi(X, Z).</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def find_flux_surf(\n    x: npt.NDArray[np.float64],\n    z: npt.NDArray[np.float64],\n    psi_norm: npt.NDArray[np.float64],\n    psi_norm_value: float,\n    o_point: FluxPoint,\n) -&gt; npt.NDArray[np.float64]:\n    r\"\"\"\n    Picks a flux surface with a normalised psi norm relative to the separatrix.\n    Uses least squares to retain only the most appropriate flux surface. This\n    is taken to be the surface whose geometric centre is closest to the O-point.\n\n    Parameters\n    ----------\n    x:\n        The spatial x coordinates of the grid points [m]\n    z:\n        The spatial z coordinates of the grid points [m]\n    psi_norm:\n        The normalised poloidal magnetic flux map [-]\n    psi_norm_value:\n        The normalised psi value of the desired flux surface [-]\n    o_point:\n        O-points to use to calculate psinorm\n\n    Returns\n    -------\n    :\n        The flux surface coordinate array\n\n\n    Raises\n    ------\n    FluxSurfaceError\n        No flux surface found at psi_norm\n\n    Notes\n    -----\n    \\t:math:`{\\\\Psi}_{N} = {\\\\psi}_{O}-N({\\\\psi}_{O}-{\\\\psi}_{X})`\n\n    Uses matplotlib hacks to pick contour surfaces on psi(X, Z).\n    \"\"\"\n\n    def _f_min(x_opt: npt.NDArray, z_opt: npt.NDArray) -&gt; float:\n        \"\"\"\n        Error function for point clusters relative to base O-point.\n\n        Returns\n        -------\n        error:\n            Error for the point cluster\n        \"\"\"\n        return np.sum(\n            (np.mean(x_opt) - o_point.x) ** 2 + (np.mean(z_opt) - o_point.z) ** 2,\n        )\n\n    psi_surfs = get_contours(x, z, psi_norm, psi_norm_value)\n\n    if not psi_surfs:\n        raise FluxSurfaceError(\n            f\"No flux surface found for psi_norm = {psi_norm_value:.4f}\",\n        )\n\n    # Choose the most logical flux surface\n    err = [_f_min(*group.T) for group in psi_surfs]\n    return psi_surfs[np.argmin(err)].T\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.interpolate_flux_surface","title":"<code>interpolate_flux_surface(x, z, n_points)</code>","text":"Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def interpolate_flux_surface(\n    x: npt.NDArray,\n    z: npt.NDArray,\n    n_points: int,\n) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    seg_lengths = np.hypot(np.diff(x), np.diff(z))\n    s = np.concatenate(([0], np.cumsum(seg_lengths)))\n\n    fx = interp1d(s, x, kind=\"linear\")\n    fz = interp1d(s, z, kind=\"linear\")\n\n    s_uniform = np.linspace(0, s[-1], n_points, endpoint=False)  # n unique points\n    x_new = fx(s_uniform)\n    z_new = fz(s_uniform)\n    x_new = np.append(x_new, x_new[0])\n    z_new = np.append(z_new, z_new[0])\n    return x_new, z_new\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.normalise_psi","title":"<code>normalise_psi(psi, axis_psi, boundary_psi, convention=&lt;FluxConvention.LINEAR: 1&gt;)</code>","text":"<p>Normalise flux for a given convention.</p> <p>Parameters:</p> Name Type Description Default <code>psi</code> <code>ndarray</code> <p>Flux</p> required <code>axis_psi</code> <code>float</code> <p>Magnetic axis flux</p> required <code>boundary_psi</code> <code>float</code> <p>LCFS flux</p> required <code>convention</code> <code>FluxConvention</code> <p>Normalised flux convention</p> <code>&lt;FluxConvention.LINEAR: 1&gt;</code> <p>Returns:</p> Name Type Description <code>psi_norm</code> <code>ndarray</code> <p>Normalised flux</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>def normalise_psi(\n    psi: np.ndarray,\n    axis_psi: float,\n    boundary_psi: float,\n    convention: FluxConvention = FluxConvention.LINEAR,\n) -&gt; np.ndarray:\n    \"\"\"\n    Normalise flux for a given convention.\n\n    Parameters\n    ----------\n    psi:\n        Flux\n    axis_psi:\n        Magnetic axis flux\n    boundary_psi:\n        LCFS flux\n    convention:\n        Normalised flux convention\n\n    Returns\n    -------\n    psi_norm:\n        Normalised flux\n    \"\"\"\n    psi_norm = (axis_psi - psi) / (axis_psi - boundary_psi)\n    psi_norm = np.clip(psi_norm, 0.0, None)\n    if convention == FluxConvention.SQRT:\n        psi_norm = np.sqrt(psi_norm)\n    return psi_norm\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.get_area_2d","title":"<code>get_area_2d(x, y)</code>","text":"<p>Calculate the area inside a closed polygon with x, y coordinate vectors. <code>Link Shoelace method &lt;https://en.wikipedia.org/wiki/Shoelace_formula&gt;</code>_</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The first set of coordinates [m]</p> required <code>y</code> <code>ndarray</code> <p>The second set of coordinates [m]</p> required <p>Returns:</p> Type Description <code>float</code> <p>The area of the polygon [m^2]</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>@nb.jit(cache=True, nopython=True)\ndef get_area_2d(x: np.ndarray, y: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculate the area inside a closed polygon with x, y coordinate vectors.\n    `Link Shoelace method &lt;https://en.wikipedia.org/wiki/Shoelace_formula&gt;`_\n\n    Parameters\n    ----------\n    x:\n        The first set of coordinates [m]\n    y:\n        The second set of coordinates [m]\n\n    Returns\n    -------\n    :\n        The area of the polygon [m^2]\n    \"\"\"\n    # No np.roll in numba\n    x = np.ascontiguousarray(x.astype(np.float64))\n    y = np.ascontiguousarray(y.astype(np.float64))\n    x1 = np.append(x[-1], x[:-1])\n    y1 = np.append(y[-1], y[:-1])\n    return 0.5 * np.abs(np.dot(x, y1) - np.dot(y, x1))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.get_centroid_2d","title":"<code>get_centroid_2d(x, z)</code>","text":"<p>Calculate the centroid of a non-self-intersecting 2-D counter-clockwise polygon.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x coordinates of the coordinates to calculate on</p> required <code>z</code> <code>ndarray</code> <p>z coordinates of the coordinates to calculate on</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The x, z coordinates of the centroid [m]</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>@nb.jit(cache=True, nopython=True)\ndef get_centroid_2d(x: np.ndarray, z: np.ndarray) -&gt; list[float]:\n    \"\"\"\n    Calculate the centroid of a non-self-intersecting 2-D counter-clockwise polygon.\n\n    Parameters\n    ----------\n    x:\n        x coordinates of the coordinates to calculate on\n    z:\n        z coordinates of the coordinates to calculate on\n\n    Returns\n    -------\n    :\n        The x, z coordinates of the centroid [m]\n    \"\"\"\n    if not check_ccw(x, z):\n        x = np.ascontiguousarray(x[::-1])\n        z = np.ascontiguousarray(z[::-1])\n    area = get_area_2d(x, z)\n\n    cx, cz = 0, 0\n    for i in range(len(x) - 1):\n        a = x[i] * z[i + 1] - x[i + 1] * z[i]\n        cx += (x[i] + x[i + 1]) * a\n        cz += (z[i] + z[i + 1]) * a\n\n    if area != 0:\n        # Zero division protection\n        cx /= 6 * area\n        cz /= 6 * area\n\n    return [cx, cz]\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/flux/#tokamak_neutron_source.flux.load_eqdsk","title":"<code>load_eqdsk(file)</code>","text":"<p>Load an EQDSK file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | EQDSKInterface</code> <p>The path to the EQDSK file.</p> required <p>Returns:</p> Type Description <code>EQDSKInterface</code> <p>The EQDSKInterface object.</p> Notes <p>Enforces the local convention that psi on axis is higher than psi on the boundary. This way, we do not need to ask the user what COCOS convention they are using.</p> <p>The actual values of psi are irrelevant here, and may be changed to enforce this convention.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def load_eqdsk(file: str | EQDSKInterface) -&gt; EQDSKInterface:\n    \"\"\"\n    Load an EQDSK file.\n\n    Parameters\n    ----------\n    file:\n        The path to the EQDSK file.\n\n    Returns\n    -------\n    :\n        The EQDSKInterface object.\n\n    Notes\n    -----\n    Enforces the local convention that psi on axis is higher than\n    psi on the boundary. This way, we do not need to ask the user\n    what COCOS convention they are using.\n\n    The actual values of psi are irrelevant here, and may be changed\n    to enforce this convention.\n    \"\"\"\n    eq = EQDSKInterface.from_file(file, no_cocos=True) if isinstance(file, str) else file\n\n    if eq.psimag &lt; eq.psibdry:\n        offset = eq.psimag\n        eq.psi = offset - eq.psi\n        eq.psibdry = offset - eq.psibdry\n        eq.psimag = 0.0\n    return eq\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/","title":"main","text":"<p>Neutromak user-facing API.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.AllReactions","title":"<code>AllReactions = tokamak_neutron_source.reactions.Reactions | tokamak_neutron_source.reactions.AneutronicReactions</code>  <code>module-attribute</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.CUSTOM_ORDER","title":"<code>CUSTOM_ORDER = [&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;, &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;, &lt;AneutronicReactions.D_D: ReactionData(label='D + D \u2192 T + p', total_energy=6.461016407480568e-13, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a64df10&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00])), ballabio_spectrum=None)&gt;, &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;, &lt;AneutronicReactions.D_He3: ReactionData(label='D + \u00b3He \u2192 \u2074He + p', total_energy=2.940668400408501e-12, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a7e9450&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;]</code>  <code>module-attribute</code>","text":"<p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TYPE_CHECKING","title":"<code>TYPE_CHECKING = False</code>  <code>module-attribute</code>","text":"<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.annotations","title":"<code>annotations = _Feature((3, 7, 0, 'beta', 1), None, 16777216)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource","title":"<code>TokamakNeutronSource</code>","text":"<p>Tokamak neutron source object.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>TransportInformation</code> <p>Plasma profile information and species composition.</p> required <code>flux_map</code> <code>FluxMap</code> <p>Magneto-hydrodynamic equilibrium poloidal magnetic flux map containing LCFS geometry and the psi_norm inside of it.</p> required <code>source_type</code> <code>AllReactions | list[AllReactions] | None</code> <p>Which neutronic reaction(s) to include in the neutron source.</p> <code>None</code> <code>cell_side_length</code> <code>float</code> <p>Discretisation in [m] for sampling the 2-D poloidal plane within the LCFS. Square cells of side length <code>cell_side_length</code> are created.</p> <code>0.1</code> <code>total_fusion_power</code> <code>float | None</code> <p>If specified, will be used to normalise the source strength to a prescribed fusion power</p> <code>None</code> <code>reactivity_method</code> <code>ReactivityMethod</code> <p>Which method to use when calculating reactivities</p> <code>&lt;ReactivityMethod.BOSCH_HALE: 2&gt;</code> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>class TokamakNeutronSource:\n    \"\"\"\n    Tokamak neutron source object.\n\n    Parameters\n    ----------\n    transport:\n        Plasma profile information and species composition.\n    flux_map:\n        Magneto-hydrodynamic equilibrium poloidal magnetic flux map containing LCFS\n        geometry and the psi_norm inside of it.\n    source_type:\n        Which neutronic reaction(s) to include in the neutron source.\n    cell_side_length:\n        Discretisation in [m] for sampling the 2-D poloidal plane within the LCFS.\n        Square cells of side length `cell_side_length` are created.\n    total_fusion_power:\n        If specified, will be used to normalise the source strength to a prescribed\n        fusion power\n    reactivity_method:\n        Which method to use when calculating reactivities\n    \"\"\"\n\n    def __init__(\n        self,\n        transport: TransportInformation,\n        flux_map: FluxMap,\n        source_type: AllReactions | list[AllReactions] | None = None,\n        cell_side_length: float = 0.1,\n        total_fusion_power: float | None = None,\n        reactivity_method: ReactivityMethod = ReactivityMethod.BOSCH_HALE,\n    ):\n        self.source_type = _parse_source_type(source_type)\n\n        self.x, self.z, self.d_volume = sample_space_2d(\n            flux_map.lcfs, flux_map.o_point, cell_side_length\n        )\n        self.cell_side_length = cell_side_length\n        psi_norm = flux_map.psi_norm(self.x, self.z)\n\n        self.temperature = transport.temperature_profile.value(psi_norm)\n        density_d = transport.deuterium_density_profile.value(psi_norm)\n        density_t = transport.tritium_density_profile.value(psi_norm)\n        density_he3 = transport.helium3_density_profile.value(psi_norm)\n\n        # All reactions (neutronic and aneutronic)\n        self.strength = {}\n        self.num_reactions_per_second = {}\n        self.num_neutrons_per_second = {}\n        for reaction in self.source_type:\n            n1_n2_sigma = density_weighted_reactivity(\n                self.temperature,\n                density_d,\n                density_t,\n                density_he3,\n                reaction=reaction,\n                method=reactivity_method,\n            )\n            self.strength[reaction] = n1_n2_sigma * self.d_volume\n            self.num_reactions_per_second[reaction] = sum(self.strength[reaction])\n            self.num_neutrons_per_second[reaction] = (\n                self.num_reactions_per_second[reaction] * reaction.num_neutrons\n            )\n\n        self.flux_map = flux_map\n        self.transport = transport\n\n        if total_fusion_power is not None:\n            self.normalise_fusion_power(total_fusion_power)\n\n    @property\n    def source_rate(self) -&gt; float:\n        \"\"\"\n        The total source rate in [neutrons / s].\n        \"\"\"\n        return sum(self.num_neutrons_per_second.values())\n\n    @property\n    def source_T_rate(self) -&gt; float:  # noqa: N802\n        \"\"\"\n        The T consumption rate in [tritons / s].\n\n        Notes\n        -----\n        If you are using a \"(n,Xt)\" tally to calculate TBR, note that the definition\n        of TBR is relative to the number of D-T reactions, not the total number\n        of fusion reactions.\n\n        To correctly scale your \"(n,Xt)\" tally in [1/particles], you should scale by:\n            tbr *= source_rate / source_T_rate\n        \"\"\"\n        return sum([\n            self.num_reactions_per_second.get(Reactions.D_T, 0.0),\n            2.0 * self.num_reactions_per_second.get(Reactions.T_T, 0.0),\n        ])\n\n    def calculate_total_fusion_power(self) -&gt; float:\n        \"\"\"\n        Calculate the total fusion power from all reaction channels.\n\n        Returns\n        -------\n        total_fusion_power\n            The total fusion power\n\n        Notes\n        -----\n        The aneutronic fusion reactions are included here.\n        \"\"\"\n        return sum(\n            np.sum(\n                self.strength[reaction] * reaction.total_energy,\n            )\n            for reaction in self.source_type\n        )\n\n    def normalise_fusion_power(self, total_fusion_power: float):\n        \"\"\"\n        Renormalise the source strength to match a total fusion power across all\n        channels.\n\n        Parameters\n        ----------\n        total_fusion_power:\n            The total fusion power to normalise to [W]\n\n        Notes\n        -----\n        This is done assuming the provided total fusion power is for the\n        same channels as the source_type. The ratios of the strengths of\n        each reaction is assumed to be same as modelled here.\n        \"\"\"\n        actual_fusion_power = self.calculate_total_fusion_power()\n        scaling_factor = total_fusion_power / actual_fusion_power\n\n        for reaction in self.source_type:\n            self.strength[reaction] *= scaling_factor\n            self.num_reactions_per_second[reaction] *= scaling_factor\n            self.num_neutrons_per_second[reaction] *= scaling_factor\n\n    def to_openmc_source(\n        self,\n        energy_method: EnergySpectrumMethod = EnergySpectrumMethod.AUTO,\n    ) -&gt; list[IndependentSource]:\n        \"\"\"\n        Create an OpenMC tokamak neutron source.\n\n        Parameters\n        ----------\n        energy_method:\n            Which method to use when calculating neutron spectra\n\n        Returns\n        -------\n        :\n            List of native OpenMC source objects\n        \"\"\"\n        from tokamak_neutron_source.openmc_interface import (  # noqa: PLC0415\n            make_openmc_full_combined_source,\n        )\n\n        return make_openmc_full_combined_source(\n            self.x,\n            self.z,\n            self.temperature,\n            self.strength,\n            self.source_rate,\n            energy_method,\n        )\n\n    def to_sdef_card(self, filename) -&gt; str:\n        \"\"\"\n        Create an SDEF card which MCNP/openmc can use to make a tokamak neutron source.\n\n        Notes\n        -----\n        The position-dependence of neutron energies be captured by SDEF. Therefore the\n        energy distribution of neutrons is averaged, and the same (frozen) distribution\n        is used everywhere in the reactor.\n        \"\"\"\n        write_mcnp_sdef_source(\n            filename,\n            self.x,\n            self.z,\n            self.cell_side_length,\n            self.temperature,\n            self.strength,\n        )\n\n    def to_h5_source(self):\n        \"\"\"\n        Create a source in the HDF5 format such that the full distribution of neutron\n        energies and position\n\n        Returns\n        -------\n        :\n            H5 format\n        \"\"\"\n        raise NotImplementedError\n\n    def plot(\n        self, reactions: list[AllReactions] | None = None\n    ) -&gt; tuple[plt.Figure, plt.Axes]:\n        \"\"\"\n        Plot the tokamak neutron source.\n\n        Returns\n        -------\n        f:\n            Matplotlib figure object\n        ax:\n            Matplotlib axes object\n\n        Raises\n        ------\n        TNSError\n            If the requested reactions are not in the source\n        \"\"\"\n        if reactions is None:\n            plot_reactions = self.source_type\n        else:\n            plot_reactions = []\n            for reaction in reactions:\n                if reaction in self.source_type:\n                    plot_reactions.append(reaction)\n                else:\n                    logger.warning(\n                        f\"Cannot plot reaction {reaction}; it was not specified upon \"\n                        \"instantiation.\"\n                    )\n            if len(plot_reactions) == 0:\n                raise TNSError(\"No valid reactions to plot.\")\n\n        f, ax = plt.subplots(1, len(plot_reactions), figsize=[15, 8])\n        if len(plot_reactions) == 1:\n            ax = [ax]\n\n        for axis, reaction in zip(ax, plot_reactions, strict=False):\n            self.flux_map.plot(f=f, ax=axis)\n            axis.set_title(f\"{reaction.label} reaction\")\n            cm = axis.scatter(\n                self.x,\n                self.z,\n                c=self.strength[reaction],\n                cmap=\"inferno\",\n            )\n\n            # Make a colorbar axis that matches the plotting area's height\n            divider = make_axes_locatable(axis)\n            cax = divider.append_axes(\"right\", size=\"9%\", pad=0.08)\n            cb = f.colorbar(cm, cax=cax)\n\n            # Put label on top\n            cb.ax.set_title(\"[1/s]\")\n            axis.plot(self.flux_map.lcfs.x, self.flux_map.lcfs.z, color=\"r\")\n            axis.plot(self.flux_map.o_point.x, self.flux_map.o_point.z, \"o\", color=\"b\")\n        f.tight_layout()\n        plt.show()\n        return f, ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.source_T_rate","title":"<code>source_T_rate</code>  <code>property</code>","text":"<p>The T consumption rate in [tritons / s].</p> Notes <p>If you are using a \"(n,Xt)\" tally to calculate TBR, note that the definition of TBR is relative to the number of D-T reactions, not the total number of fusion reactions.</p> <p>To correctly scale your \"(n,Xt)\" tally in [1/particles], you should scale by:     tbr *= source_rate / source_T_rate</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.source_rate","title":"<code>source_rate</code>  <code>property</code>","text":"<p>The total source rate in [neutrons / s].</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.calculate_total_fusion_power","title":"<code>calculate_total_fusion_power()</code>","text":"<p>Calculate the total fusion power from all reaction channels.</p> <p>Returns:</p> Type Description <code>total_fusion_power</code> <p>The total fusion power</p> Notes <p>The aneutronic fusion reactions are included here.</p> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>def calculate_total_fusion_power(self) -&gt; float:\n    \"\"\"\n    Calculate the total fusion power from all reaction channels.\n\n    Returns\n    -------\n    total_fusion_power\n        The total fusion power\n\n    Notes\n    -----\n    The aneutronic fusion reactions are included here.\n    \"\"\"\n    return sum(\n        np.sum(\n            self.strength[reaction] * reaction.total_energy,\n        )\n        for reaction in self.source_type\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.normalise_fusion_power","title":"<code>normalise_fusion_power(total_fusion_power)</code>","text":"<p>Renormalise the source strength to match a total fusion power across all channels.</p> <p>Parameters:</p> Name Type Description Default <code>total_fusion_power</code> <code>float</code> <p>The total fusion power to normalise to [W]</p> required Notes <p>This is done assuming the provided total fusion power is for the same channels as the source_type. The ratios of the strengths of each reaction is assumed to be same as modelled here.</p> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>def normalise_fusion_power(self, total_fusion_power: float):\n    \"\"\"\n    Renormalise the source strength to match a total fusion power across all\n    channels.\n\n    Parameters\n    ----------\n    total_fusion_power:\n        The total fusion power to normalise to [W]\n\n    Notes\n    -----\n    This is done assuming the provided total fusion power is for the\n    same channels as the source_type. The ratios of the strengths of\n    each reaction is assumed to be same as modelled here.\n    \"\"\"\n    actual_fusion_power = self.calculate_total_fusion_power()\n    scaling_factor = total_fusion_power / actual_fusion_power\n\n    for reaction in self.source_type:\n        self.strength[reaction] *= scaling_factor\n        self.num_reactions_per_second[reaction] *= scaling_factor\n        self.num_neutrons_per_second[reaction] *= scaling_factor\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.to_openmc_source","title":"<code>to_openmc_source(energy_method=&lt;EnergySpectrumMethod.AUTO: 4&gt;)</code>","text":"<p>Create an OpenMC tokamak neutron source.</p> <p>Parameters:</p> Name Type Description Default <code>energy_method</code> <code>EnergySpectrumMethod</code> <p>Which method to use when calculating neutron spectra</p> <code>&lt;EnergySpectrumMethod.AUTO: 4&gt;</code> <p>Returns:</p> Type Description <code>list[IndependentSource]</code> <p>List of native OpenMC source objects</p> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>def to_openmc_source(\n    self,\n    energy_method: EnergySpectrumMethod = EnergySpectrumMethod.AUTO,\n) -&gt; list[IndependentSource]:\n    \"\"\"\n    Create an OpenMC tokamak neutron source.\n\n    Parameters\n    ----------\n    energy_method:\n        Which method to use when calculating neutron spectra\n\n    Returns\n    -------\n    :\n        List of native OpenMC source objects\n    \"\"\"\n    from tokamak_neutron_source.openmc_interface import (  # noqa: PLC0415\n        make_openmc_full_combined_source,\n    )\n\n    return make_openmc_full_combined_source(\n        self.x,\n        self.z,\n        self.temperature,\n        self.strength,\n        self.source_rate,\n        energy_method,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.to_sdef_card","title":"<code>to_sdef_card(filename)</code>","text":"<p>Create an SDEF card which MCNP/openmc can use to make a tokamak neutron source.</p> Notes <p>The position-dependence of neutron energies be captured by SDEF. Therefore the energy distribution of neutrons is averaged, and the same (frozen) distribution is used everywhere in the reactor.</p> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>def to_sdef_card(self, filename) -&gt; str:\n    \"\"\"\n    Create an SDEF card which MCNP/openmc can use to make a tokamak neutron source.\n\n    Notes\n    -----\n    The position-dependence of neutron energies be captured by SDEF. Therefore the\n    energy distribution of neutrons is averaged, and the same (frozen) distribution\n    is used everywhere in the reactor.\n    \"\"\"\n    write_mcnp_sdef_source(\n        filename,\n        self.x,\n        self.z,\n        self.cell_side_length,\n        self.temperature,\n        self.strength,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.to_h5_source","title":"<code>to_h5_source()</code>","text":"<p>Create a source in the HDF5 format such that the full distribution of neutron energies and position</p> <p>Returns:</p> Type Description <p>H5 format</p> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>def to_h5_source(self):\n    \"\"\"\n    Create a source in the HDF5 format such that the full distribution of neutron\n    energies and position\n\n    Returns\n    -------\n    :\n        H5 format\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TokamakNeutronSource.plot","title":"<code>plot(reactions=None)</code>","text":"<p>Plot the tokamak neutron source.</p> <p>Returns:</p> Name Type Description <code>f</code> <code>Figure</code> <p>Matplotlib figure object</p> <code>ax</code> <code>Axes</code> <p>Matplotlib axes object</p> <p>Raises:</p> Type Description <code>TNSError</code> <p>If the requested reactions are not in the source</p> Source code in <code>tokamak_neutron_source/main.py</code> <pre><code>def plot(\n    self, reactions: list[AllReactions] | None = None\n) -&gt; tuple[plt.Figure, plt.Axes]:\n    \"\"\"\n    Plot the tokamak neutron source.\n\n    Returns\n    -------\n    f:\n        Matplotlib figure object\n    ax:\n        Matplotlib axes object\n\n    Raises\n    ------\n    TNSError\n        If the requested reactions are not in the source\n    \"\"\"\n    if reactions is None:\n        plot_reactions = self.source_type\n    else:\n        plot_reactions = []\n        for reaction in reactions:\n            if reaction in self.source_type:\n                plot_reactions.append(reaction)\n            else:\n                logger.warning(\n                    f\"Cannot plot reaction {reaction}; it was not specified upon \"\n                    \"instantiation.\"\n                )\n        if len(plot_reactions) == 0:\n            raise TNSError(\"No valid reactions to plot.\")\n\n    f, ax = plt.subplots(1, len(plot_reactions), figsize=[15, 8])\n    if len(plot_reactions) == 1:\n        ax = [ax]\n\n    for axis, reaction in zip(ax, plot_reactions, strict=False):\n        self.flux_map.plot(f=f, ax=axis)\n        axis.set_title(f\"{reaction.label} reaction\")\n        cm = axis.scatter(\n            self.x,\n            self.z,\n            c=self.strength[reaction],\n            cmap=\"inferno\",\n        )\n\n        # Make a colorbar axis that matches the plotting area's height\n        divider = make_axes_locatable(axis)\n        cax = divider.append_axes(\"right\", size=\"9%\", pad=0.08)\n        cb = f.colorbar(cm, cax=cax)\n\n        # Put label on top\n        cb.ax.set_title(\"[1/s]\")\n        axis.plot(self.flux_map.lcfs.x, self.flux_map.lcfs.z, color=\"r\")\n        axis.plot(self.flux_map.o_point.x, self.flux_map.o_point.z, \"o\", color=\"b\")\n    f.tight_layout()\n    plt.show()\n    return f, ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.AneutronicReactions","title":"<code>AneutronicReactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Aneutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class AneutronicReactions(ReactionEnumMixin, Enum):\n    \"\"\"Aneutronic reaction channels.\"\"\"\n\n    D_D = ReactionData(\n        label=\"D + D \u2192 T + p\",\n        total_energy=E_DD_TP_FUSION,\n        num_neutrons=0,  # no neutrons in aneutronic branch\n        cross_section=DD_TP_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_TP,\n        ballabio_spectrum=None,\n    )\n    D_He3 = ReactionData(\n        label=\"D + \u00b3He \u2192 \u2074He + p\",\n        total_energy=E_DHE3_FUSION,\n        num_neutrons=0,\n        cross_section=DHE3_HEP_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.AneutronicReactions.D_D","title":"<code>D_D = &lt;AneutronicReactions.D_D: ReactionData(label='D + D \u2192 T + p', total_energy=6.461016407480568e-13, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a64df10&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00])), ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.AneutronicReactions.D_He3","title":"<code>D_He3 = &lt;AneutronicReactions.D_He3: ReactionData(label='D + \u00b3He \u2192 \u2074He + p', total_energy=2.940668400408501e-12, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a7e9450&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.EnergySpectrumMethod","title":"<code>EnergySpectrumMethod</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Energy spectrum calculation method.</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>class EnergySpectrumMethod(Enum):\n    \"\"\"Energy spectrum calculation method.\"\"\"\n\n    DATA = auto()\n    BALLABIO_GAUSSIAN = auto()\n    BALLABIO_M_GAUSSIAN = auto()\n    AUTO = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.EnergySpectrumMethod.AUTO","title":"<code>AUTO = &lt;EnergySpectrumMethod.AUTO: 4&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.EnergySpectrumMethod.BALLABIO_GAUSSIAN","title":"<code>BALLABIO_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_GAUSSIAN: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.EnergySpectrumMethod.BALLABIO_M_GAUSSIAN","title":"<code>BALLABIO_M_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.EnergySpectrumMethod.DATA","title":"<code>DATA = &lt;EnergySpectrumMethod.DATA: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.Reactions","title":"<code>Reactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Neutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class Reactions(ReactionEnumMixin, Enum):\n    \"\"\"Neutronic reaction channels.\"\"\"\n\n    D_T = ReactionData(\n        label=\"D + T \u2192 \u2074He + n\",\n        total_energy=E_DT_FUSION,\n        num_neutrons=1,\n        cross_section=DT_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DT_4HEN,\n        ballabio_spectrum=BALLABIO_DT_NEUTRON,\n    )\n    D_D = ReactionData(\n        label=\"D + D \u2192 \u00b3He + n\",\n        total_energy=E_DD_HE3N_FUSION,\n        num_neutrons=1,\n        cross_section=DD_HE3N_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_3HEN,\n        ballabio_spectrum=BALLABIO_DD_NEUTRON,\n    )\n    T_T = ReactionData(\n        label=\"T + T \u2192 \u2074He + 2n\",\n        total_energy=E_TT_FUSION,\n        num_neutrons=2,\n        cross_section=TT_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.Reactions.D_D","title":"<code>D_D = &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.Reactions.D_T","title":"<code>D_T = &lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.Reactions.T_T","title":"<code>T_T = &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.ReactivityError","title":"<code>ReactivityError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Reactivity error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class ReactivityError(TNSError):\n    \"\"\"Reactivity error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.ReactivityMethod","title":"<code>ReactivityMethod</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Reactivity calculation method.</p> Source code in <code>tokamak_neutron_source/reactivity.py</code> <pre><code>class ReactivityMethod(Enum):\n    \"\"\"Reactivity calculation method.\"\"\"\n\n    XS = auto()\n    BOSCH_HALE = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.ReactivityMethod.BOSCH_HALE","title":"<code>BOSCH_HALE = &lt;ReactivityMethod.BOSCH_HALE: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Reactivity calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.ReactivityMethod.XS","title":"<code>XS = &lt;ReactivityMethod.XS: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Reactivity calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.TNSError","title":"<code>TNSError</code>","text":"<p>               Bases: <code>builtins.Exception</code></p> <p>Base exception class. Sub-class from this for module level Errors.</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class TNSError(Exception):\n    \"\"\"\n    Base exception class. Sub-class from this for module level Errors.\n    \"\"\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Prettier handling of the Exception strings.\n\n        Returns\n        -------\n        :\n            The formatted exception string.\n        \"\"\"\n        return fill(dedent(self.args[0]))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.density_weighted_reactivity","title":"<code>density_weighted_reactivity(temp_kev, density_d, density_t, density_he3, reaction=&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;, method=&lt;ReactivityMethod.BOSCH_HALE: 2&gt;)</code>","text":"<p>Calculate the density-weighted thermal reactivity of a fusion reaction in Maxwellian plasmas, \\t:math:<code>n_1 n_2 &lt;\\sigma v&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Temperature [keV]</p> required <code>density_d</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Deuterium density [m^-3]</p> required <code>density_t</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Tritium density [m^-3]</p> required <code>density_he3</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Helium-3 density [m^-3]</p> required <code>reaction</code> <code>str | Reactions | AneutronicReactions</code> <p>The fusion reaction</p> <code>&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09,  1.51361e-02,  7.51886e-02,  4.60643e-03,         1.35000e-02, -1.06750e-04,  1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code> <code>method</code> <code>ReactivityMethod</code> <p>The method to use when calculating the reactivity</p> <code>&lt;ReactivityMethod.BOSCH_HALE: 2&gt;</code> <p>Returns:</p> Type Description <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Density-weighted reactivity of the reaction at the specified temperature(s) [1/m^3/s]</p> Source code in <code>tokamak_neutron_source/reactivity.py</code> <pre><code>def density_weighted_reactivity(\n    temp_kev: float | npt.NDArray,\n    density_d: float | npt.NDArray,\n    density_t: float | npt.NDArray,\n    density_he3: float | npt.NDArray,\n    reaction: str | AllReactions = Reactions.D_T,\n    method: ReactivityMethod = ReactivityMethod.BOSCH_HALE,\n) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the density-weighted thermal reactivity of a fusion reaction in\n    Maxwellian plasmas, \\\\t:math:`n_1 n_2 &lt;\\\\sigma v&gt;`.\n\n    Parameters\n    ----------\n    temp_kev:\n        Temperature [keV]\n    density_d:\n        Deuterium density [m^-3]\n    density_t:\n        Tritium density [m^-3]\n    density_he3:\n        Helium-3 density [m^-3]\n    reaction:\n        The fusion reaction\n    method:\n        The method to use when calculating the reactivity\n\n    Returns\n    -------\n    :\n        Density-weighted reactivity of the reaction at the specified temperature(s)\n        [1/m^3/s]\n    \"\"\"\n    reaction = _parse_reaction(reaction)\n\n    match reaction:\n        case Reactions.D_D | AneutronicReactions.D_D:\n            n1_n2 = density_d * density_d / 2\n        case Reactions.D_T:\n            n1_n2 = density_d * density_t\n        case Reactions.T_T:\n            n1_n2 = density_t * density_t / 2\n        case AneutronicReactions.D_He3:\n            n1_n2 = density_d * density_he3\n        case _:\n            raise NotImplementedError(f\"Reaction {reaction} not implemented.\")\n\n    return n1_n2 * reactivity(temp_kev, reaction, method)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.sample_space_2d","title":"<code>sample_space_2d(lcfs, o_point, cell_side_length)</code>","text":"<p>Sample the 2-D poloidal plane within the LCFS.</p> <p>Parameters:</p> Name Type Description Default <code>lcfs</code> <code>ClosedFluxSurface</code> <p>Last closed flux surface</p> required <code>o_point</code> <code>FluxPoint</code> <p>O-point location</p> required <code>cell_side_length</code> <code>float</code> <p>Side length of square cells [m]</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Radial coordinates of sampled points [m]</p> <code>z</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Vertical coordinates of sampled points [m]</p> <code>d_volume</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Volumes of cells centred at points [m^3]</p> Notes <p>Creates points at the centres of square cells of fixed size (cell_side_length by cell_side_length). Only cells whose centres fall inside the LCFS polygon are kept. Cells are positioned such that the  centre of one cell lies on the O-point.</p> Source code in <code>tokamak_neutron_source/space.py</code> <pre><code>def sample_space_2d(\n    lcfs: ClosedFluxSurface,\n    o_point: FluxPoint,\n    cell_side_length: float,\n) -&gt; tuple[npt.NDArray, npt.NDArray, npt.NDArray]:\n    \"\"\"\n    Sample the 2-D poloidal plane within the LCFS.\n\n    Parameters\n    ----------\n    lcfs:\n        Last closed flux surface\n    o_point:\n        O-point location\n    cell_side_length:\n        Side length of square cells [m]\n\n    Returns\n    -------\n    x:\n        Radial coordinates of sampled points [m]\n    z:\n        Vertical coordinates of sampled points [m]\n    d_volume:\n        Volumes of cells centred at points [m^3]\n\n    Notes\n    -----\n    Creates points at the centres of square cells of fixed size\n    (cell_side_length by cell_side_length). Only cells whose centres fall\n    inside the LCFS polygon are kept.\n    Cells are positioned such that the  centre of one cell lies on\n    the O-point.\n    \"\"\"\n    # Get bounding box around LCFS (+ offset)\n    polygon_path = Path(np.c_[lcfs.x, lcfs.z])\n    off = 2.0 * cell_side_length  # Just to be sure\n    x_min, x_max = np.min(lcfs.x) - off, np.max(lcfs.x) + off\n    z_min, z_max = np.min(lcfs.z) - off, np.max(lcfs.z) + off\n\n    # Shift grid so O-point lies on a cell center\n    dx = (o_point.x - x_min) % cell_side_length - 0.5 * cell_side_length\n    dz = (o_point.z - z_min) % cell_side_length - 0.5 * cell_side_length\n\n    # Construct grid\n    x_centers = np.arange(x_min + dx, x_max, cell_side_length) + 0.5 * cell_side_length\n    z_centers = np.arange(z_min + dz, z_max, cell_side_length) + 0.5 * cell_side_length\n    x, z = np.meshgrid(x_centers, z_centers, indexing=\"ij\")\n    points = np.c_[x.ravel(), z.ravel()]\n\n    # Mask by LCFS polygon\n    inside = polygon_path.contains_points(points)\n    points = points[inside]\n\n    # Volumes: toroidal rotation of each square cell\n    d_volume = 2 * np.pi * points[:, 0] * cell_side_length**2\n\n    return points[:, 0], points[:, 1], d_volume\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/main/#tokamak_neutron_source.main.write_mcnp_sdef_source","title":"<code>write_mcnp_sdef_source(file, r, z, cell_side_length, temperature, strength)</code>","text":"<p>Write an MCNP SDEF source for a ring source at (r,z).</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>The file name stub to which to write the SDEF source</p> required <code>r</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Radial positions of the rings [m]</p> required <code>z</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Vertical positions of the rings [m]</p> required <code>cell_side_length</code> <code>float</code> <p>side length of square source cell</p> required <code>temperature</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Ion temperatures at the rings [keV]</p> required <code>strength</code> <code>dict[Reactions | AneutronicReactions, ndarray[tuple[Any, ...], dtype[~_ScalarT]]]</code> <p>Dictionary of strengths for each reaction at the rings [arbitrary units]</p> required Notes <p>Only Neutronic reactions are written to SDEF file Aneutronic reactions are ignored. The radial distribution bouldaries and probabilities are set to the SI3 and SP3 cards The DS4 card is used as the dependent distribution numbers for the vertical distributions</p> Source code in <code>tokamak_neutron_source/mcnp_interface.py</code> <pre><code>def write_mcnp_sdef_source(\n    file: str | Path,\n    r: npt.NDArray,\n    z: npt.NDArray,\n    cell_side_length: float,\n    temperature: npt.NDArray,\n    strength: dict[AllReactions, npt.NDArray],\n):\n    \"\"\"\n    Write an MCNP SDEF source for a ring source at (r,z).\n\n    Parameters\n    ----------\n    file:\n        The file name stub to which to write the SDEF source\n    r:\n        Radial positions of the rings [m]\n    z:\n        Vertical positions of the rings [m]\n    cell_side_length:\n        side length of square source cell\n    temperature:\n        Ion temperatures at the rings [keV]\n    strength:\n        Dictionary of strengths for each reaction at the rings [arbitrary units]\n\n    Notes\n    -----\n    Only Neutronic reactions are written to SDEF file Aneutronic reactions are ignored.\n    The radial distribution bouldaries and probabilities are set to the SI3 and SP3 cards\n    The DS4 card is used as the dependent distribution numbers\n    for the vertical distributions\n\n    \"\"\"\n    r = raw_uc(r, \"m\", \"cm\")\n    z = raw_uc(z, \"m\", \"cm\")\n    dr = raw_uc(cell_side_length, \"m\", \"cm\")\n\n    # Half widths of 'cells'\n    drad = dzed = dr / 2\n\n    offset = 5  # First 5 distribution are reserved\n\n    for reaction, r_data in strength.items():\n        if reaction not in AneutronicReactions:\n            short_react = re.findall(r\"[DT]\", reaction.label)\n            file_name = f\"{file}.{short_react[0]}{short_react[1]}\"\n\n            header = sdef_header(reaction, r_data, temperature)\n\n            # Calculate the radial boundaries based on the ring centres\n            # and 'cell width' (dr)\n            r_bounds = np.unique(r) - drad\n            r_bounds = np.append(r_bounds, r_bounds[-1] + dr)  # Add the last boundary\n\n            # Identify where radial position changes\n            # and therefore the range of each vertical distribution\n            z_ints = np.concatenate([[-1], np.nonzero(r[1:] != r[:-1])[0], [len(r) - 1]])\n\n            si_card = _text_wrap(\n                \"SI3 H \" + \" \".join(f\"{ri:.5e}\" for ri in r_bounds), new_lines=1\n            )\n            sp_card = _text_wrap(\n                f\"SP3 D {0.0:.5e} \"\n                + \" \".join(\n                    f\"{np.sum(r_data[z_ints[i] + 1 : z_ints[i + 1] + 1]):.5e}\"\n                    for i in range(len(z_ints) - 1)\n                ),\n                new_lines=1,\n            )\n\n            ds_card = _text_wrap(\n                \"DS4 S \"\n                + \" \".join(f\"{i:d}\" for i in range(offset, offset + len(r_bounds) - 1)),\n                new_lines=1,\n            )\n\n            with open(file_name, \"w\") as sdef_file:\n                sdef_file.write(\n                    f\"{header}{si_card}{sp_card}{ds_card}\"\n                    \"C\\nC 3. Neutron Emission Probability - Vertical Distribution\\nC\\n\"\n                )\n                for si_card, sp_card in _si_sp_vertical_dist_cards(\n                    offset, z, z_ints, dzed, r_data\n                ):\n                    sdef_file.write(f\"{si_card}{sp_card}\")\n\n        else:\n            logger.info(f\"Skipping reaction {reaction.label} for MCNP SDEF source.\")\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/","title":"mcnp_interface","text":"<p>MCNP neutron source (SDEF) interface</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.AllReactions","title":"<code>AllReactions = tokamak_neutron_source.reactions.Reactions | tokamak_neutron_source.reactions.AneutronicReactions</code>  <code>module-attribute</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.AneutronicReactions","title":"<code>AneutronicReactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Aneutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class AneutronicReactions(ReactionEnumMixin, Enum):\n    \"\"\"Aneutronic reaction channels.\"\"\"\n\n    D_D = ReactionData(\n        label=\"D + D \u2192 T + p\",\n        total_energy=E_DD_TP_FUSION,\n        num_neutrons=0,  # no neutrons in aneutronic branch\n        cross_section=DD_TP_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_TP,\n        ballabio_spectrum=None,\n    )\n    D_He3 = ReactionData(\n        label=\"D + \u00b3He \u2192 \u2074He + p\",\n        total_energy=E_DHE3_FUSION,\n        num_neutrons=0,\n        cross_section=DHE3_HEP_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.AneutronicReactions.D_D","title":"<code>D_D = &lt;AneutronicReactions.D_D: ReactionData(label='D + D \u2192 T + p', total_energy=6.461016407480568e-13, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a64df10&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00])), ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.AneutronicReactions.D_He3","title":"<code>D_He3 = &lt;AneutronicReactions.D_He3: ReactionData(label='D + \u00b3He \u2192 \u2074He + p', total_energy=2.940668400408501e-12, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a7e9450&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.EnergySpectrumMethod","title":"<code>EnergySpectrumMethod</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Energy spectrum calculation method.</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>class EnergySpectrumMethod(Enum):\n    \"\"\"Energy spectrum calculation method.\"\"\"\n\n    DATA = auto()\n    BALLABIO_GAUSSIAN = auto()\n    BALLABIO_M_GAUSSIAN = auto()\n    AUTO = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.EnergySpectrumMethod.AUTO","title":"<code>AUTO = &lt;EnergySpectrumMethod.AUTO: 4&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.EnergySpectrumMethod.BALLABIO_GAUSSIAN","title":"<code>BALLABIO_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_GAUSSIAN: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.EnergySpectrumMethod.BALLABIO_M_GAUSSIAN","title":"<code>BALLABIO_M_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.EnergySpectrumMethod.DATA","title":"<code>DATA = &lt;EnergySpectrumMethod.DATA: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.Reactions","title":"<code>Reactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Neutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class Reactions(ReactionEnumMixin, Enum):\n    \"\"\"Neutronic reaction channels.\"\"\"\n\n    D_T = ReactionData(\n        label=\"D + T \u2192 \u2074He + n\",\n        total_energy=E_DT_FUSION,\n        num_neutrons=1,\n        cross_section=DT_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DT_4HEN,\n        ballabio_spectrum=BALLABIO_DT_NEUTRON,\n    )\n    D_D = ReactionData(\n        label=\"D + D \u2192 \u00b3He + n\",\n        total_energy=E_DD_HE3N_FUSION,\n        num_neutrons=1,\n        cross_section=DD_HE3N_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_3HEN,\n        ballabio_spectrum=BALLABIO_DD_NEUTRON,\n    )\n    T_T = ReactionData(\n        label=\"T + T \u2192 \u2074He + 2n\",\n        total_energy=E_TT_FUSION,\n        num_neutrons=2,\n        cross_section=TT_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.Reactions.D_D","title":"<code>D_D = &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.Reactions.D_T","title":"<code>D_T = &lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.Reactions.T_T","title":"<code>T_T = &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.write_mcnp_sdef_source","title":"<code>write_mcnp_sdef_source(file, r, z, cell_side_length, temperature, strength)</code>","text":"<p>Write an MCNP SDEF source for a ring source at (r,z).</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>The file name stub to which to write the SDEF source</p> required <code>r</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Radial positions of the rings [m]</p> required <code>z</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Vertical positions of the rings [m]</p> required <code>cell_side_length</code> <code>float</code> <p>side length of square source cell</p> required <code>temperature</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Ion temperatures at the rings [keV]</p> required <code>strength</code> <code>dict[Reactions | AneutronicReactions, ndarray[tuple[Any, ...], dtype[~_ScalarT]]]</code> <p>Dictionary of strengths for each reaction at the rings [arbitrary units]</p> required Notes <p>Only Neutronic reactions are written to SDEF file Aneutronic reactions are ignored. The radial distribution bouldaries and probabilities are set to the SI3 and SP3 cards The DS4 card is used as the dependent distribution numbers for the vertical distributions</p> Source code in <code>tokamak_neutron_source/mcnp_interface.py</code> <pre><code>def write_mcnp_sdef_source(\n    file: str | Path,\n    r: npt.NDArray,\n    z: npt.NDArray,\n    cell_side_length: float,\n    temperature: npt.NDArray,\n    strength: dict[AllReactions, npt.NDArray],\n):\n    \"\"\"\n    Write an MCNP SDEF source for a ring source at (r,z).\n\n    Parameters\n    ----------\n    file:\n        The file name stub to which to write the SDEF source\n    r:\n        Radial positions of the rings [m]\n    z:\n        Vertical positions of the rings [m]\n    cell_side_length:\n        side length of square source cell\n    temperature:\n        Ion temperatures at the rings [keV]\n    strength:\n        Dictionary of strengths for each reaction at the rings [arbitrary units]\n\n    Notes\n    -----\n    Only Neutronic reactions are written to SDEF file Aneutronic reactions are ignored.\n    The radial distribution bouldaries and probabilities are set to the SI3 and SP3 cards\n    The DS4 card is used as the dependent distribution numbers\n    for the vertical distributions\n\n    \"\"\"\n    r = raw_uc(r, \"m\", \"cm\")\n    z = raw_uc(z, \"m\", \"cm\")\n    dr = raw_uc(cell_side_length, \"m\", \"cm\")\n\n    # Half widths of 'cells'\n    drad = dzed = dr / 2\n\n    offset = 5  # First 5 distribution are reserved\n\n    for reaction, r_data in strength.items():\n        if reaction not in AneutronicReactions:\n            short_react = re.findall(r\"[DT]\", reaction.label)\n            file_name = f\"{file}.{short_react[0]}{short_react[1]}\"\n\n            header = sdef_header(reaction, r_data, temperature)\n\n            # Calculate the radial boundaries based on the ring centres\n            # and 'cell width' (dr)\n            r_bounds = np.unique(r) - drad\n            r_bounds = np.append(r_bounds, r_bounds[-1] + dr)  # Add the last boundary\n\n            # Identify where radial position changes\n            # and therefore the range of each vertical distribution\n            z_ints = np.concatenate([[-1], np.nonzero(r[1:] != r[:-1])[0], [len(r) - 1]])\n\n            si_card = _text_wrap(\n                \"SI3 H \" + \" \".join(f\"{ri:.5e}\" for ri in r_bounds), new_lines=1\n            )\n            sp_card = _text_wrap(\n                f\"SP3 D {0.0:.5e} \"\n                + \" \".join(\n                    f\"{np.sum(r_data[z_ints[i] + 1 : z_ints[i + 1] + 1]):.5e}\"\n                    for i in range(len(z_ints) - 1)\n                ),\n                new_lines=1,\n            )\n\n            ds_card = _text_wrap(\n                \"DS4 S \"\n                + \" \".join(f\"{i:d}\" for i in range(offset, offset + len(r_bounds) - 1)),\n                new_lines=1,\n            )\n\n            with open(file_name, \"w\") as sdef_file:\n                sdef_file.write(\n                    f\"{header}{si_card}{sp_card}{ds_card}\"\n                    \"C\\nC 3. Neutron Emission Probability - Vertical Distribution\\nC\\n\"\n                )\n                for si_card, sp_card in _si_sp_vertical_dist_cards(\n                    offset, z, z_ints, dzed, r_data\n                ):\n                    sdef_file.write(f\"{si_card}{sp_card}\")\n\n        else:\n            logger.info(f\"Skipping reaction {reaction.label} for MCNP SDEF source.\")\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.sdef_header","title":"<code>sdef_header(reaction, reaction_data, temperature)</code>","text":"<p>Create SDEF file header</p> <p>Parameters:</p> Name Type Description Default <code>reaction</code> <code>Reactions</code> <p>Reaction to be created</p> required <code>reaction_data</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>strength of source</p> required <code>temperature</code> <code>float</code> <p>Ion temperature</p> required Notes <p>For DT and DD reactions MCNP's built-in gaussian spectrums are used For TT reactions the tabulated data is used</p> Source code in <code>tokamak_neutron_source/mcnp_interface.py</code> <pre><code>def sdef_header(\n    reaction: Reactions, reaction_data: npt.NDArray, temperature: float\n) -&gt; str:\n    \"\"\"Create SDEF file header\n\n    Parameters\n    ----------\n    reaction:\n        Reaction to be created\n    reaction_data:\n        strength of source\n    temperature:\n        Ion temperature\n\n    Notes\n    -----\n    For DT and DD reactions MCNP's built-in gaussian spectrums are used\n    For TT reactions the tabulated data is used\n\n    \"\"\"  # noqa: DOC201\n    strength = sum(reaction_data)\n    ion_temp = mean_ion_temp(reaction_data, temperature)\n\n    # Read authors and git address from CITATION.cff\n    citation = load_citation()\n    authors = \"\\n\".join(\n        (\n            f\"C    {author.get('given-names', '')}\"\n            f\" {author.get('family-names', '')},\"\n            f\" {author.get('affiliation', '')}\"\n        )\n        for author in citation.get(\"authors\", [])\n    )\n    gitaddr = citation.get(\"repository-code\", \"\")\n\n    if reaction in {Reactions.D_T, Reactions.D_D}:\n        # -1 for D-T and -2 for D-D\n        reaction_data = (\n            f\"SP2 -4 {raw_uc(ion_temp, 'keV', 'MeV'):5e} \"\n            f\"{-1 if reaction == Reactions.D_T else -2}\\n\"\n        )\n\n    elif reaction == Reactions.T_T:\n        energies, probabilities = energy_spectrum(\n            ion_temp, reaction, EnergySpectrumMethod.DATA\n        )\n        reaction_data = \"SI2 H \" + _text_wrap(\n            f\"{0.0:.5e} \" + \" \".join(f\"{e:.5e}\" for e in raw_uc(energies, \"keV\", \"MeV\"))\n        )\n        reaction_data += \"SP2 D \" + _text_wrap(\n            f\"{0.0:.5e} \" + \" \".join(f\"{p:.5e}\" for p in probabilities)\n        )\n\n    return f\"\"\"C ============================\nC SDEF Card for Tokamak Neutron Source generated by:\nC {gitaddr}\nC ============================\nC\nC ============================\nC Authors:\n{authors}\nC ============================\nC\nC ============================\nC Method:\nC 1. Create a cylinder that encloses the entire torus.\nC 2. Then slice the cylinder along the R-axis.\nC 3. Finally, define the vertical distribution, assuming rotational symmetry.\nC ============================\nC\nC ============================\nC Reaction channel: {reaction.label}\nC Total source neutrons: {strength:5e} n/s\nC ============================\nC\nC 1. Neutron Emission Probability - Set up cylindrical source\nC\nsdef erg=d2 par=1 wgt=1\n      pos = 0 0 0    $ Center = origin\n      axs = 0 0 1    $ Cylinder points along the Z axis\n      rad = d3       $ radial distribution defined by distribution 3\n      ext = frad d4  $ extent distribution defined by distribution 4 which is dependent on distribution rad\n{reaction_data}C\nC 2. Neutron Emission Probability - Radial Distribution\nC\n\"\"\"  # noqa: E501\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.mean_ion_temp","title":"<code>mean_ion_temp(strength, temperature)</code>","text":"<p>Calculate the strength-weighted mean ion temperature.</p> Source code in <code>tokamak_neutron_source/mcnp_interface.py</code> <pre><code>def mean_ion_temp(strength: npt.NDArray, temperature: npt.NDArray) -&gt; float:\n    \"\"\"Calculate the strength-weighted mean ion temperature.\"\"\"  # noqa: DOC201\n    return np.sum(strength * temperature) / np.sum(strength)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.energy_spectrum","title":"<code>energy_spectrum(temp_kev, reaction, method=&lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;)</code>","text":"<p>Calculate the tabulated energy spectrum of a reaction at a given ion temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float</code> <p>Ion temperature</p> required <code>reaction</code> <code>Reactions</code> <p>Neutronic fusion reaction</p> required <code>method</code> <code>EnergySpectrumMethod</code> <p>Method to use to calculate the energy spectrum</p> <code>&lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code> <p>Returns:</p> Name Type Description <code>energies</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>The energy bins of the probability distribution function</p> <code>pdf</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>The PDF values</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>def energy_spectrum(\n    temp_kev: float,\n    reaction: Reactions,\n    method: EnergySpectrumMethod = EnergySpectrumMethod.BALLABIO_M_GAUSSIAN,\n) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    \"\"\"\n    Calculate the tabulated energy spectrum of a reaction at a given ion temperature.\n\n    Parameters\n    ----------\n    temp_kev:\n        Ion temperature\n    reaction:\n        Neutronic fusion reaction\n    method:\n        Method to use to calculate the energy spectrum\n\n    Returns\n    -------\n    energies:\n        The energy bins of the probability distribution function\n    pdf:\n        The PDF values\n    \"\"\"\n    match method:\n        case (\n            EnergySpectrumMethod.BALLABIO_GAUSSIAN\n            | EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n        ):\n            if reaction.ballabio_spectrum is not None:\n                return _ballabio_spectrum(reaction.ballabio_spectrum, temp_kev, method)\n\n            logger.warning(\n                f\"There is no Ballabio parameterisation for reaction {reaction.name}, \"\n                \"returning energy spectrum calculated by data.\",\n                stacklevel=5,\n            )\n            return _data_spectrum(reaction, temp_kev)\n\n        case EnergySpectrumMethod.DATA:\n            return _data_spectrum(reaction, temp_kev)\n        case EnergySpectrumMethod.AUTO:\n            match reaction:\n                case Reactions.D_D | Reactions.D_T:\n                    return energy_spectrum(\n                        temp_kev, reaction, EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n                    )\n                case Reactions.T_T:\n                    return energy_spectrum(temp_kev, reaction, EnergySpectrumMethod.DATA)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.load_citation","title":"<code>load_citation()</code>","text":"<p>Load the CITATION.cff file.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The contents of the CITATION.cff file as a dictionary.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def load_citation() -&gt; dict:\n    \"\"\"\n    Load the CITATION.cff file.\n\n    Returns\n    -------\n    :\n        The contents of the CITATION.cff file as a dictionary.\n    \"\"\"\n    with open(get_tns_path(\"data\") / \"CITATION.cff\") as citation_file:\n        return yaml.safe_load(citation_file)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/mcnp_interface/#tokamak_neutron_source.mcnp_interface.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/","title":"openmc_interface","text":"<p>OpenMC neutron source interface.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.AllReactions","title":"<code>AllReactions = tokamak_neutron_source.reactions.Reactions | tokamak_neutron_source.reactions.AneutronicReactions</code>  <code>module-attribute</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.EnergySpectrumMethod","title":"<code>EnergySpectrumMethod</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Energy spectrum calculation method.</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>class EnergySpectrumMethod(Enum):\n    \"\"\"Energy spectrum calculation method.\"\"\"\n\n    DATA = auto()\n    BALLABIO_GAUSSIAN = auto()\n    BALLABIO_M_GAUSSIAN = auto()\n    AUTO = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.EnergySpectrumMethod.AUTO","title":"<code>AUTO = &lt;EnergySpectrumMethod.AUTO: 4&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.EnergySpectrumMethod.BALLABIO_GAUSSIAN","title":"<code>BALLABIO_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_GAUSSIAN: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.EnergySpectrumMethod.BALLABIO_M_GAUSSIAN","title":"<code>BALLABIO_M_GAUSSIAN = &lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.EnergySpectrumMethod.DATA","title":"<code>DATA = &lt;EnergySpectrumMethod.DATA: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Energy spectrum calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.QuietTTSpectrumWarnings","title":"<code>QuietTTSpectrumWarnings</code>","text":"<p>               Bases: <code>tokamak_neutron_source.tools.WarningFilter</code></p> <p>Filter away all duplicate warnings from the energy and energy_data module.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>class QuietTTSpectrumWarnings(WarningFilter):\n    \"\"\"Filter away all duplicate warnings from the energy and energy_data module.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            \"tokamak_neutron_source.energy\", \"tokamak_neutron_source.energy_data\"\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.Reactions","title":"<code>Reactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Neutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class Reactions(ReactionEnumMixin, Enum):\n    \"\"\"Neutronic reaction channels.\"\"\"\n\n    D_T = ReactionData(\n        label=\"D + T \u2192 \u2074He + n\",\n        total_energy=E_DT_FUSION,\n        num_neutrons=1,\n        cross_section=DT_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DT_4HEN,\n        ballabio_spectrum=BALLABIO_DT_NEUTRON,\n    )\n    D_D = ReactionData(\n        label=\"D + D \u2192 \u00b3He + n\",\n        total_energy=E_DD_HE3N_FUSION,\n        num_neutrons=1,\n        cross_section=DD_HE3N_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_3HEN,\n        ballabio_spectrum=BALLABIO_DD_NEUTRON,\n    )\n    T_T = ReactionData(\n        label=\"T + T \u2192 \u2074He + 2n\",\n        total_energy=E_TT_FUSION,\n        num_neutrons=2,\n        cross_section=TT_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.Reactions.D_D","title":"<code>D_D = &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.Reactions.D_T","title":"<code>D_T = &lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.Reactions.T_T","title":"<code>T_T = &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.get_neutron_energy_spectrum","title":"<code>get_neutron_energy_spectrum(reaction, temp_kev, method)</code>","text":"<p>Get a native OpenMC neutron energy spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>reaction</code> <code>Reactions</code> <p>The neutronic reaction for which to retrieve the neutron spectrum</p> required <code>temp_kev</code> <code>float</code> <p>The ion temperature of the reactants</p> required <code>method</code> <code>EnergySpectrumMethod</code> <p>Which method to use when calculating the energy spectrum</p> required <p>Returns:</p> Type Description <code>Tabular | Discrete</code> <p>OpenMC tabular neutron energy distribution for the given reaction.</p> Notes <p>Log-linear interpolation is used within OpenMC.</p> Source code in <code>tokamak_neutron_source/openmc_interface.py</code> <pre><code>def get_neutron_energy_spectrum(\n    reaction: Reactions, temp_kev: float, method: EnergySpectrumMethod\n) -&gt; Tabular | Discrete:\n    \"\"\"\n    Get a native OpenMC neutron energy spectrum.\n\n    Parameters\n    ----------\n    reaction:\n        The neutronic reaction for which to retrieve the neutron spectrum\n    temp_kev: float\n        The ion temperature of the reactants\n    method:\n        Which method to use when calculating the energy spectrum\n\n    Returns\n    -------\n    :\n        OpenMC tabular neutron energy distribution for the given reaction.\n\n    Notes\n    -----\n    Log-linear interpolation is used within OpenMC.\n    \"\"\"\n    if (\n        method is EnergySpectrumMethod.BALLABIO_GAUSSIAN\n        and reaction.ballabio_spectrum is not None\n    ):\n        mean = reaction.ballabio_spectrum.mean_energy(temp_kev)\n        std = reaction.ballabio_spectrum.std_deviation(temp_kev)\n        return Normal(raw_uc(mean, \"keV\", \"eV\"), raw_uc(std, \"keV\", \"eV\"))\n    energy, probability = energy_spectrum(temp_kev, reaction, method)\n    energy_ev = raw_uc(energy, \"keV\", \"eV\")\n    # Log-linear interpolation is not supported in OpenMC at present\n    # see: https://github.com/openmc-dev/openmc/issues/2409\n    return Tabular(energy_ev, probability, interpolation=\"linear-linear\")\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.make_openmc_ring_source","title":"<code>make_openmc_ring_source(r, z, energy_distribution, strength)</code>","text":"<p>Make a single OpenMC ring source.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>Radial position of the ring [m]</p> required <code>z</code> <code>float</code> <p>Vertical position of the ring [m]</p> required <code>energy_distribution</code> <code>Any</code> <p>Neutron energy distribution</p> required <code>strength</code> <code>float</code> <p>Strength of the source [numebr of neutrons]</p> required <p>Returns:</p> Type Description <code>IndependentSource</code> <p>An OpenMC IndependentSource object, or None if strength is zero.</p> Source code in <code>tokamak_neutron_source/openmc_interface.py</code> <pre><code>def make_openmc_ring_source(\n    r: float,\n    z: float,\n    energy_distribution: Any,\n    strength: float,\n) -&gt; IndependentSource:\n    \"\"\"\n    Make a single OpenMC ring source.\n\n    Parameters\n    ----------\n    r:\n        Radial position of the ring [m]\n    z:\n        Vertical position of the ring [m]\n    energy_distribution:\n        Neutron energy distribution\n    strength:\n        Strength of the source [numebr of neutrons]\n\n    Returns\n    -------\n    :\n        An OpenMC IndependentSource object, or None if strength is zero.\n    \"\"\"\n    if strength &gt; 0:\n        return IndependentSource(\n            energy=energy_distribution,\n            space=CylindricalIndependent(\n                r=Discrete([raw_uc(r, \"m\", \"cm\")], [1.0]),\n                phi=Uniform(0, 2 * np.pi),\n                z=Discrete([raw_uc(z, \"m\", \"cm\")], [1.0]),\n                origin=(0.0, 0.0, 0.0),\n            ),\n            angle=Isotropic(),\n            strength=strength,\n        )\n    return None\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.make_openmc_full_combined_source","title":"<code>make_openmc_full_combined_source(r, z, temperature, strength, source_rate, energy_spectrum_method)</code>","text":"<p>Make an OpenMC source combining multiple reactions across the whole plasma.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Radial positions of the rings [m]</p> required <code>z</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Vertical positions of the rings [m]</p> required <code>temperature</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Ion temperatures at the rings [keV]</p> required <code>strength</code> <code>dict[Reactions | AneutronicReactions, ndarray[tuple[Any, ...], dtype[~_ScalarT]]]</code> <p>Dictionary of strengths for each reaction at the rings [neutrons]</p> required <code>source_rate</code> <code>float</code> <p>Total source rate [neutrons/s]</p> required <code>energy_spectrum_method</code> <code>EnergySpectrumMethod</code> <p>Which method to use when calculating neutron spectra</p> required <p>Returns:</p> Type Description <code>IndependentSource</code> <p>A list of OpenMC IndependentSource objects, one per ring.</p> Source code in <code>tokamak_neutron_source/openmc_interface.py</code> <pre><code>def make_openmc_full_combined_source(\n    r: npt.NDArray,\n    z: npt.NDArray,\n    temperature: npt.NDArray,\n    strength: dict[AllReactions, npt.NDArray],\n    source_rate: float,\n    energy_spectrum_method: EnergySpectrumMethod,\n) -&gt; IndependentSource:\n    \"\"\"\n    Make an OpenMC source combining multiple reactions across the whole plasma.\n\n    Parameters\n    ----------\n    r:\n        Radial positions of the rings [m]\n    z:\n        Vertical positions of the rings [m]\n    temperature:\n        Ion temperatures at the rings [keV]\n    strength:\n        Dictionary of strengths for each reaction at the rings [neutrons]\n    source_rate:\n        Total source rate [neutrons/s]\n    energy_spectrum_method:\n        Which method to use when calculating neutron spectra\n\n    Returns\n    -------\n    :\n        A list of OpenMC IndependentSource objects, one per ring.\n    \"\"\"\n    sources = []\n    # Neutronic reaction channels only\n    # We multiply the T-T channel by 2 because it is 2n\n    n_strength = {\n        reaction: rate * reaction.num_neutrons\n        for reaction, rate in strength.items()\n        if isinstance(reaction, Reactions)\n    }\n\n    with QuietTTSpectrumWarnings():\n        for i, (ri, zi, ti) in enumerate(zip(r, z, temperature, strict=False)):\n            distributions = []\n            weights = []\n\n            for reaction, s in n_strength.items():\n                if s[i] &gt; 0.0:\n                    distributions.append(\n                        get_neutron_energy_spectrum(reaction, ti, energy_spectrum_method)\n                    )\n                    weights.append(s[i])\n\n            local_strength = sum(weights)\n\n            distribution = Mixture(np.array(weights) / local_strength, distributions)\n\n            source = make_openmc_ring_source(\n                ri, zi, distribution, local_strength / source_rate\n            )\n            if source is not None:\n                sources.append(source)\n\n    return sources\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.energy_spectrum","title":"<code>energy_spectrum(temp_kev, reaction, method=&lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;)</code>","text":"<p>Calculate the tabulated energy spectrum of a reaction at a given ion temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float</code> <p>Ion temperature</p> required <code>reaction</code> <code>Reactions</code> <p>Neutronic fusion reaction</p> required <code>method</code> <code>EnergySpectrumMethod</code> <p>Method to use to calculate the energy spectrum</p> <code>&lt;EnergySpectrumMethod.BALLABIO_M_GAUSSIAN: 3&gt;</code> <p>Returns:</p> Name Type Description <code>energies</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>The energy bins of the probability distribution function</p> <code>pdf</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>The PDF values</p> Source code in <code>tokamak_neutron_source/energy.py</code> <pre><code>def energy_spectrum(\n    temp_kev: float,\n    reaction: Reactions,\n    method: EnergySpectrumMethod = EnergySpectrumMethod.BALLABIO_M_GAUSSIAN,\n) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    \"\"\"\n    Calculate the tabulated energy spectrum of a reaction at a given ion temperature.\n\n    Parameters\n    ----------\n    temp_kev:\n        Ion temperature\n    reaction:\n        Neutronic fusion reaction\n    method:\n        Method to use to calculate the energy spectrum\n\n    Returns\n    -------\n    energies:\n        The energy bins of the probability distribution function\n    pdf:\n        The PDF values\n    \"\"\"\n    match method:\n        case (\n            EnergySpectrumMethod.BALLABIO_GAUSSIAN\n            | EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n        ):\n            if reaction.ballabio_spectrum is not None:\n                return _ballabio_spectrum(reaction.ballabio_spectrum, temp_kev, method)\n\n            logger.warning(\n                f\"There is no Ballabio parameterisation for reaction {reaction.name}, \"\n                \"returning energy spectrum calculated by data.\",\n                stacklevel=5,\n            )\n            return _data_spectrum(reaction, temp_kev)\n\n        case EnergySpectrumMethod.DATA:\n            return _data_spectrum(reaction, temp_kev)\n        case EnergySpectrumMethod.AUTO:\n            match reaction:\n                case Reactions.D_D | Reactions.D_T:\n                    return energy_spectrum(\n                        temp_kev, reaction, EnergySpectrumMethod.BALLABIO_M_GAUSSIAN\n                    )\n                case Reactions.T_T:\n                    return energy_spectrum(temp_kev, reaction, EnergySpectrumMethod.DATA)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/openmc_interface/#tokamak_neutron_source.openmc_interface.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/","title":"profile","text":"<p>Simple 1-D profile structures and parameterisations</p>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.PlasmaProfile","title":"<code>PlasmaProfile</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Abstract base class for plasma profiles.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>class PlasmaProfile(ABC):\n    \"\"\"Abstract base class for plasma profiles.\"\"\"\n\n    def __init__(self, scale: float = 1.0):\n        self._scale = scale\n\n    @abstractmethod\n    def value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n        \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"\n\n    def set_scale(self, scale: float = 1.0):\n        \"\"\"Set the scale of the rho value. Multiplies existing scale.\"\"\"\n        self._scale *= scale\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.PlasmaProfile.value","title":"<code>value(rho)</code>","text":"<p>Calculate the value of the profile at given value(s) of rho.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>@abstractmethod\ndef value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n    \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.PlasmaProfile.set_scale","title":"<code>set_scale(scale=1.0)</code>","text":"<p>Set the scale of the rho value. Multiplies existing scale.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>def set_scale(self, scale: float = 1.0):\n    \"\"\"Set the scale of the rho value. Multiplies existing scale.\"\"\"\n    self._scale *= scale\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.DataProfile","title":"<code>DataProfile</code>","text":"<p>               Bases: <code>tokamak_neutron_source.profile.PlasmaProfile</code></p> <p>Plasma profile from data.</p> Notes <p>Normalised radius conventions are not enforced here. Linear interpolation is used.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>class DataProfile(PlasmaProfile):\n    \"\"\"\n    Plasma profile from data.\n\n    Notes\n    -----\n    Normalised radius conventions are not enforced here.\n    Linear interpolation is used.\n    \"\"\"\n\n    def __init__(self, values: npt.NDArray, rho: npt.NDArray, *, scale: float = 1.0):\n        super().__init__(scale)\n        self._values = values\n        self._rho = rho\n        self._interpolator = interp1d(self._rho, self._values, kind=\"linear\")\n\n    def value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n        \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"  # noqa: DOC201\n        rho = np.clip(rho, 0.0, 1.0)\n        return self._scale * self._interpolator(rho)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.DataProfile.value","title":"<code>value(rho)</code>","text":"<p>Calculate the value of the profile at given value(s) of rho.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>def value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n    \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"  # noqa: DOC201\n    rho = np.clip(rho, 0.0, 1.0)\n    return self._scale * self._interpolator(rho)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.ParabolicProfile","title":"<code>ParabolicProfile</code>","text":"<p>               Bases: <code>tokamak_neutron_source.profile.PlasmaProfile</code></p> <p>Parabolic plasma profile parameterisation defined e.g. in :doi:<code>Lao 1985 &lt;10.1088/0029-5515/25/11/007&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>core_value</code> <code>float</code> <p>Value of the profile at rho = 0</p> required <code>alpha</code> <code>float</code> <p>Alpha exponent</p> required <code>beta</code> <code>float</code> <p>Beta exponent</p> required Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>class ParabolicProfile(PlasmaProfile):\n    \"\"\"\n    Parabolic plasma profile parameterisation defined e.g. in\n    :doi:`Lao 1985 &lt;10.1088/0029-5515/25/11/007&gt;`.\n\n    Parameters\n    ----------\n    core_value:\n        Value of the profile at rho = 0\n    alpha:\n        Alpha exponent\n    beta:\n        Beta exponent\n    \"\"\"\n\n    def __init__(self, core_value: float, alpha: float, beta: float):\n        super().__init__()\n        self.core_value = core_value\n        self.alpha = alpha\n        self.beta = beta\n\n    def value(self, rho):\n        \"\"\"\n        Parabolic with pedestal profile function\n\n        Parameters\n        ----------\n        rho:\n            Values of the normalised radius at which to calculate the profile\n            value\n\n        Returns\n        -------\n        values:\n            The value(s) of the profile at rho.\n\n        Notes\n        -----\n        \\t:math:`g(\\rho)=(1-\\rho^{\\beta})^{\\alpha}`\n        \"\"\"\n        rho = np.clip(rho, 0, 1)\n        # sign tweak needed to avoid runtime warnings in np\n        f = 1 - np.sign(rho) * np.abs(rho) ** self.beta\n        values = self.core_value * np.sign(f) * (np.abs(f)) ** self.alpha\n        return self._scale * values\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.ParabolicProfile.value","title":"<code>value(rho)</code>","text":"<p>Parabolic with pedestal profile function</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>Values of the normalised radius at which to calculate the profile value</p> required <p>Returns:</p> Name Type Description <code>values</code> <p>The value(s) of the profile at rho.</p> Notes <pre><code>    :math:`g(\n</code></pre> <p>ho)=(1- ho^{\beta})^{\u0007lpha}`</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>def value(self, rho):\n    \"\"\"\n    Parabolic with pedestal profile function\n\n    Parameters\n    ----------\n    rho:\n        Values of the normalised radius at which to calculate the profile\n        value\n\n    Returns\n    -------\n    values:\n        The value(s) of the profile at rho.\n\n    Notes\n    -----\n    \\t:math:`g(\\rho)=(1-\\rho^{\\beta})^{\\alpha}`\n    \"\"\"\n    rho = np.clip(rho, 0, 1)\n    # sign tweak needed to avoid runtime warnings in np\n    f = 1 - np.sign(rho) * np.abs(rho) ** self.beta\n    values = self.core_value * np.sign(f) * (np.abs(f)) ** self.alpha\n    return self._scale * values\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.ParabolicPedestalProfile","title":"<code>ParabolicPedestalProfile</code>","text":"<p>               Bases: <code>tokamak_neutron_source.profile.PlasmaProfile</code></p> <p>Parabolic pedestal plasma profile parameterisation.</p> <p>Parameters:</p> Name Type Description Default <code>rho_ped</code> <code>float</code> <p>Pedestal normalised radius</p> required <code>core_value</code> <code>float</code> <p>Value of the profile at rho = 0</p> required <code>ped_value</code> <code>float</code> <p>Value of the profile at rho = rho_ped</p> required <code>sep_value</code> <code>float</code> <p>Value of the profile at rho = 1</p> required <code>alpha</code> <code>float</code> <p>Alpha exponent</p> required <code>beta</code> <code>float</code> <p>Beta exponent</p> required <code>rho_ped</code> <code>float</code> <p>Normalised radius of the pedestal</p> required Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>class ParabolicPedestalProfile(PlasmaProfile):\n    \"\"\"\n    Parabolic pedestal plasma profile parameterisation.\n\n    Parameters\n    ----------\n    rho_ped:\n        Pedestal normalised radius\n    core_value:\n        Value of the profile at rho = 0\n    ped_value:\n        Value of the profile at rho = rho_ped\n    sep_value:\n        Value of the profile at rho = 1\n    alpha:\n        Alpha exponent\n    beta:\n        Beta exponent\n    rho_ped:\n        Normalised radius of the pedestal\n    \"\"\"\n\n    def __init__(\n        self,\n        core_value: float,\n        ped_value: float,\n        sep_value: float,\n        alpha: float,\n        beta: float,\n        rho_ped: float,\n    ):\n        super().__init__()\n        self.core_value = core_value\n        self.ped_value = ped_value\n        self.sep_value = sep_value\n        self.alpha = alpha\n        self.beta = beta\n        self.rho_ped = np.clip(rho_ped, 0, 1)\n\n    def value(self, rho: float | Iterable) -&gt; float | Iterable:\n        \"\"\"\n        Parabolic with pedestal profile function\n\n        Parameters\n        ----------\n        rho:\n            Values of the normalised radius at which to calculate the profile\n            value\n\n        Returns\n        -------\n        values:\n            The value(s) of the profile at rho.\n        \"\"\"\n        rho = np.asarray(rho, dtype=float)\n        rho = np.clip(rho, 0.0, 1.0)\n\n        rho_rho_ped_beta = (rho / self.rho_ped) ** self.beta\n        # Clip to avoid small zeros (-EPS)\n        term = np.clip(1.0 - rho_rho_ped_beta, 0.0, 1.0)\n\n        # Core region: rho &lt; rho_ped\n        core_part = (\n            self.ped_value + (self.core_value - self.ped_value) * term**self.alpha\n        )\n\n        # Pedestal region: rho &gt;= rho_ped\n        if self.rho_ped == 1.0:\n            ped_part = np.full_like(rho, self.sep_value)\n        else:\n            ped_part = self.sep_value + (self.ped_value - self.sep_value) * (1 - rho) / (\n                1 - self.rho_ped\n            )\n\n        # Combine regions\n        values = np.where(rho &lt; self.rho_ped, core_part, ped_part)\n        values *= self._scale\n\n        # Return scalar if input was scalar\n        return values.item() if np.isscalar(rho) or values.shape == () else values\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/profile/#tokamak_neutron_source.profile.ParabolicPedestalProfile.value","title":"<code>value(rho)</code>","text":"<p>Parabolic with pedestal profile function</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>float | Iterable</code> <p>Values of the normalised radius at which to calculate the profile value</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>float | Iterable</code> <p>The value(s) of the profile at rho.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>def value(self, rho: float | Iterable) -&gt; float | Iterable:\n    \"\"\"\n    Parabolic with pedestal profile function\n\n    Parameters\n    ----------\n    rho:\n        Values of the normalised radius at which to calculate the profile\n        value\n\n    Returns\n    -------\n    values:\n        The value(s) of the profile at rho.\n    \"\"\"\n    rho = np.asarray(rho, dtype=float)\n    rho = np.clip(rho, 0.0, 1.0)\n\n    rho_rho_ped_beta = (rho / self.rho_ped) ** self.beta\n    # Clip to avoid small zeros (-EPS)\n    term = np.clip(1.0 - rho_rho_ped_beta, 0.0, 1.0)\n\n    # Core region: rho &lt; rho_ped\n    core_part = (\n        self.ped_value + (self.core_value - self.ped_value) * term**self.alpha\n    )\n\n    # Pedestal region: rho &gt;= rho_ped\n    if self.rho_ped == 1.0:\n        ped_part = np.full_like(rho, self.sep_value)\n    else:\n        ped_part = self.sep_value + (self.ped_value - self.sep_value) * (1 - rho) / (\n            1 - self.rho_ped\n        )\n\n    # Combine regions\n    values = np.where(rho &lt; self.rho_ped, core_part, ped_part)\n    values *= self._scale\n\n    # Return scalar if input was scalar\n    return values.item() if np.isscalar(rho) or values.shape == () else values\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/","title":"reactions","text":"<p>Fusion reactions and their data.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.AllReactions","title":"<code>AllReactions = tokamak_neutron_source.reactions.Reactions | tokamak_neutron_source.reactions.AneutronicReactions</code>  <code>module-attribute</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BALLABIO_DD_NEUTRON","title":"<code>BALLABIO_DD_NEUTRON = BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946))</code>  <code>module-attribute</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BALLABIO_DT_NEUTRON","title":"<code>BALLABIO_DT_NEUTRON = BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05))</code>  <code>module-attribute</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BOSCH_HALE_DD_3HEN","title":"<code>BOSCH_HALE_DD_3HEN = BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00]))</code>  <code>module-attribute</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BOSCH_HALE_DD_TP","title":"<code>BOSCH_HALE_DD_TP = BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00]))</code>  <code>module-attribute</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BOSCH_HALE_DT_4HEN","title":"<code>BOSCH_HALE_DT_4HEN = BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05]))</code>  <code>module-attribute</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_DD_HE3N_FUSION","title":"<code>E_DD_HE3N_FUSION = 5.237367559215132e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_DD_NEUTRON","title":"<code>E_DD_NEUTRON = 3.924425728571561e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_DD_TP_FUSION","title":"<code>E_DD_TP_FUSION = 6.461016407480568e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_DHE3_FUSION","title":"<code>E_DHE3_FUSION = 2.940668400408501e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_DT_FUSION","title":"<code>E_DT_FUSION = 2.8183035155819573e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_DT_NEUTRON","title":"<code>E_DT_NEUTRON = 2.250912784396904e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_TT_FUSION","title":"<code>E_TT_FUSION = 1.8157845541890245e-12</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.E_TT_NEUTRON","title":"<code>E_TT_NEUTRON = 7.546109313264398e-13</code>  <code>module-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionData","title":"<code>ReactionData</code>","text":"<p>Reaction dataclass.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>@dataclass(frozen=True)\nclass ReactionData:\n    \"\"\"Reaction dataclass.\"\"\"\n\n    label: str\n    total_energy: float\n    num_neutrons: int\n    cross_section: ReactionCrossSection\n    bosch_hale_coefficients: BoschHaleCoefficients | None\n    ballabio_spectrum: BallabioEnergySpectrum | None\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin","title":"<code>ReactionEnumMixin</code>","text":"<p>Provides convenient accessors to the underlying ReactionData.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class ReactionEnumMixin:\n    \"\"\"Provides convenient accessors to the underlying ReactionData.\"\"\"\n\n    @property\n    def data(self) -&gt; ReactionData:  # noqa: D102\n        return self.value\n\n    @property\n    def label(self) -&gt; str:  # noqa: D102\n        return self.value.label\n\n    @property\n    def total_energy(self) -&gt; float:  # noqa: D102\n        return self.value.total_energy\n\n    @property\n    def num_neutrons(self) -&gt; int:  # noqa: D102\n        return self.value.num_neutrons\n\n    @property\n    def cross_section(self) -&gt; ReactionCrossSection:  # noqa: D102\n        return self.value.cross_section\n\n    @property\n    def bosch_hale_coefficients(self) -&gt; BoschHaleCoefficients | None:  # noqa: D102\n        return self.value.bosch_hale_coefficients\n\n    @property\n    def ballabio_spectrum(self) -&gt; BallabioEnergySpectrum | None:  # noqa: D102\n        return self.value.ballabio_spectrum\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.ballabio_spectrum","title":"<code>ballabio_spectrum</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.bosch_hale_coefficients","title":"<code>bosch_hale_coefficients</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.cross_section","title":"<code>cross_section</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.data","title":"<code>data</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.label","title":"<code>label</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.num_neutrons","title":"<code>num_neutrons</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionEnumMixin.total_energy","title":"<code>total_energy</code>  <code>property</code>","text":""},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.Reactions","title":"<code>Reactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Neutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class Reactions(ReactionEnumMixin, Enum):\n    \"\"\"Neutronic reaction channels.\"\"\"\n\n    D_T = ReactionData(\n        label=\"D + T \u2192 \u2074He + n\",\n        total_energy=E_DT_FUSION,\n        num_neutrons=1,\n        cross_section=DT_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DT_4HEN,\n        ballabio_spectrum=BALLABIO_DT_NEUTRON,\n    )\n    D_D = ReactionData(\n        label=\"D + D \u2192 \u00b3He + n\",\n        total_energy=E_DD_HE3N_FUSION,\n        num_neutrons=1,\n        cross_section=DD_HE3N_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_3HEN,\n        ballabio_spectrum=BALLABIO_DD_NEUTRON,\n    )\n    T_T = ReactionData(\n        label=\"T + T \u2192 \u2074He + 2n\",\n        total_energy=E_TT_FUSION,\n        num_neutrons=2,\n        cross_section=TT_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.Reactions.D_D","title":"<code>D_D = &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.Reactions.D_T","title":"<code>D_T = &lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.Reactions.T_T","title":"<code>T_T = &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.AneutronicReactions","title":"<code>AneutronicReactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Aneutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class AneutronicReactions(ReactionEnumMixin, Enum):\n    \"\"\"Aneutronic reaction channels.\"\"\"\n\n    D_D = ReactionData(\n        label=\"D + D \u2192 T + p\",\n        total_energy=E_DD_TP_FUSION,\n        num_neutrons=0,  # no neutrons in aneutronic branch\n        cross_section=DD_TP_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_TP,\n        ballabio_spectrum=None,\n    )\n    D_He3 = ReactionData(\n        label=\"D + \u00b3He \u2192 \u2074He + p\",\n        total_energy=E_DHE3_FUSION,\n        num_neutrons=0,\n        cross_section=DHE3_HEP_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.AneutronicReactions.D_D","title":"<code>D_D = &lt;AneutronicReactions.D_D: ReactionData(label='D + D \u2192 T + p', total_energy=6.461016407480568e-13, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a64df10&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00])), ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.AneutronicReactions.D_He3","title":"<code>D_He3 = &lt;AneutronicReactions.D_He3: ReactionData(label='D + \u00b3He \u2192 \u2074He + p', total_energy=2.940668400408501e-12, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a7e9450&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BallabioEnergySpectrum","title":"<code>BallabioEnergySpectrum</code>","text":"<p>Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian spectra.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>@dataclass\nclass BallabioEnergySpectrum:\n    \"\"\"\n    Ballabio et al. fit data for relativistic fusion reaction neutron energy Gaussian\n    spectra.\n    \"\"\"\n\n    \"\"\"E_0\"\"\"\n    energy_0: float  # [keV]\n\n    omega_0: float  # [keV]\n\n    r\"\"\"\\Delta E_{th} coefficients\"\"\"\n    energy_shift_coeffs: BallabioCoefficients\n\n    r\"\"\"\\delta_{\\omega} coefficients\"\"\"\n    width_correction_coeffs: BallabioCoefficients\n\n    def energy_shift(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        r\"\"\"\n        Calculate the energy shift \\Delta E_{th} at a given ion temperature.\n        \"\"\"  # noqa: DOC201\n        return self.energy_shift_coeffs.fit(temp_kev)\n\n    def width_correction(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        r\"\"\"\n        Calculate the width correction \\delta_{\\omega} at a given ion temperature.\n        \"\"\"  # noqa: DOC201\n        return self.width_correction_coeffs.fit(temp_kev)\n\n    def mean_energy(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the mean neutron energy at a given ion temperature\n        (primary first moment: mu).\n        \"\"\"  # noqa: DOC201\n        return self.energy_0 + self.energy_shift(temp_kev)\n\n    def std_deviation(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"\n        Calculate the standard deviation of the neutron energy spectrum at a given ion\n        temperature (primary second moment: sigma)\n        \"\"\"  # noqa: DOC201\n        # Full width at half maximum (FWHM)\n        w_12 = self.omega_0 * (1 + self.width_correction(temp_kev)) * np.sqrt(temp_kev)\n        return w_12 / TWO_SQRT_2LN2\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BallabioEnergySpectrum.energy_shift","title":"<code>energy_shift(temp_kev)</code>","text":"<p>Calculate the energy shift \\Delta E_{th} at a given ion temperature.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def energy_shift(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    r\"\"\"\n    Calculate the energy shift \\Delta E_{th} at a given ion temperature.\n    \"\"\"  # noqa: DOC201\n    return self.energy_shift_coeffs.fit(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BallabioEnergySpectrum.mean_energy","title":"<code>mean_energy(temp_kev)</code>","text":"<p>Calculate the mean neutron energy at a given ion temperature (primary first moment: mu).</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def mean_energy(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the mean neutron energy at a given ion temperature\n    (primary first moment: mu).\n    \"\"\"  # noqa: DOC201\n    return self.energy_0 + self.energy_shift(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BallabioEnergySpectrum.std_deviation","title":"<code>std_deviation(temp_kev)</code>","text":"<p>Calculate the standard deviation of the neutron energy spectrum at a given ion temperature (primary second moment: sigma)</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def std_deviation(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the standard deviation of the neutron energy spectrum at a given ion\n    temperature (primary second moment: sigma)\n    \"\"\"  # noqa: DOC201\n    # Full width at half maximum (FWHM)\n    w_12 = self.omega_0 * (1 + self.width_correction(temp_kev)) * np.sqrt(temp_kev)\n    return w_12 / TWO_SQRT_2LN2\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BallabioEnergySpectrum.width_correction","title":"<code>width_correction(temp_kev)</code>","text":"<p>Calculate the width correction \\delta_{\\omega} at a given ion temperature.</p> Source code in <code>tokamak_neutron_source/energy_data.py</code> <pre><code>def width_correction(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n    r\"\"\"\n    Calculate the width correction \\delta_{\\omega} at a given ion temperature.\n    \"\"\"  # noqa: DOC201\n    return self.width_correction_coeffs.fit(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.BoschHaleCoefficients","title":"<code>BoschHaleCoefficients</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p> Source code in <code>tokamak_neutron_source/reactivity_data.py</code> <pre><code>@dataclass\nclass BoschHaleCoefficients:\n    \"\"\"\n    Bosch-Hale parameterisation dataclass.\n\n    H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611\n    DOI 10.1088/0029-5515/32/4/I07\n    \"\"\"\n\n    name: str\n    t_min: float  # [keV]\n    t_max: float  # [keV]\n    bg: float  # [keV**0.5]\n    mrc2: float  # [keV]\n    c: npt.NDArray\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactionCrossSection","title":"<code>ReactionCrossSection</code>","text":"<p>Fusion reaction cross-section.</p> Source code in <code>tokamak_neutron_source/reactivity_data.py</code> <pre><code>class ReactionCrossSection:\n    \"\"\"Fusion reaction cross-section.\"\"\"\n\n    def __init__(self, file_name: str):\n        \"\"\"\n        Parameters\n        ----------\n        file_name:\n            Cross-sectional data file (ENDF format)\n\n        Raises\n        ------\n        ReactivityError\n            Data file path is not a file\n        \"\"\"\n        path = get_tns_path(\"data/cross_sections\")\n        path = Path(path, file_name)\n        if not path.is_file():\n            raise ReactivityError(f\"Cross-section data file {path} is not a file!\")\n\n        file = path.as_posix()\n        # Read in the cross section (in barn) as a function of energy (MeV).\n        energy, sigma = np.genfromtxt(file, comments=\"#\", skip_footer=2, unpack=True)\n\n        split = file_name.split(\".\", maxsplit=1)[0].split(\"_\")\n        collider, target = split[:2]\n        self.name = f\"{collider} + {target} -&gt; {split[2]} + {split[3]}\"\n\n        mass_1, mass_2 = MOLAR_MASSES[collider], MOLAR_MASSES[target]\n\n        self.reduced_mass = raw_uc(mass_1 * mass_2 / (mass_1 + mass_2), \"amu\", \"kg\")\n\n        # Convert to center of mass frame\n        # NOTE MC: Choice of target/collider thing makes Bosch-Hale line up...\n        energy *= mass_2 / (mass_1 + mass_2)\n\n        # Convert to kev / m^2\n        self._cross_section = interp1d(energy * 1e3, sigma * 1e-28)\n\n    def __call__(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"Get cross section at a give temperature\"\"\"  # noqa: DOC201\n        return self._cross_section(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.ReactivityError","title":"<code>ReactivityError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Reactivity error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class ReactivityError(TNSError):\n    \"\"\"Reactivity error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.DD_HE3N_XS","title":"<code>DD_HE3N_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.DD_TP_XS","title":"<code>DD_TP_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.DHE3_HEP_XS","title":"<code>DHE3_HEP_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.DT_XS","title":"<code>DT_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactions/#tokamak_neutron_source.reactions.TT_XS","title":"<code>TT_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/","title":"reactivity","text":"<p>Reactivity calculations.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.AllReactions","title":"<code>AllReactions = tokamak_neutron_source.reactions.Reactions | tokamak_neutron_source.reactions.AneutronicReactions</code>  <code>module-attribute</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.ReactivityMethod","title":"<code>ReactivityMethod</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>Reactivity calculation method.</p> Source code in <code>tokamak_neutron_source/reactivity.py</code> <pre><code>class ReactivityMethod(Enum):\n    \"\"\"Reactivity calculation method.\"\"\"\n\n    XS = auto()\n    BOSCH_HALE = auto()\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.ReactivityMethod.BOSCH_HALE","title":"<code>BOSCH_HALE = &lt;ReactivityMethod.BOSCH_HALE: 2&gt;</code>  <code>class-attribute</code>","text":"<p>Reactivity calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.ReactivityMethod.XS","title":"<code>XS = &lt;ReactivityMethod.XS: 1&gt;</code>  <code>class-attribute</code>","text":"<p>Reactivity calculation method.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.AneutronicReactions","title":"<code>AneutronicReactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Aneutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class AneutronicReactions(ReactionEnumMixin, Enum):\n    \"\"\"Aneutronic reaction channels.\"\"\"\n\n    D_D = ReactionData(\n        label=\"D + D \u2192 T + p\",\n        total_energy=E_DD_TP_FUSION,\n        num_neutrons=0,  # no neutrons in aneutronic branch\n        cross_section=DD_TP_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_TP,\n        ballabio_spectrum=None,\n    )\n    D_He3 = ReactionData(\n        label=\"D + \u00b3He \u2192 \u2074He + p\",\n        total_energy=E_DHE3_FUSION,\n        num_neutrons=0,\n        cross_section=DHE3_HEP_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.AneutronicReactions.D_D","title":"<code>D_D = &lt;AneutronicReactions.D_D: ReactionData(label='D + D \u2192 T + p', total_energy=6.461016407480568e-13, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a64df10&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00])), ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.AneutronicReactions.D_He3","title":"<code>D_He3 = &lt;AneutronicReactions.D_He3: ReactionData(label='D + \u00b3He \u2192 \u2074He + p', total_energy=2.940668400408501e-12, num_neutrons=0, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52a7e9450&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Aneutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.BoschHaleCoefficients","title":"<code>BoschHaleCoefficients</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p> Source code in <code>tokamak_neutron_source/reactivity_data.py</code> <pre><code>@dataclass\nclass BoschHaleCoefficients:\n    \"\"\"\n    Bosch-Hale parameterisation dataclass.\n\n    H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611\n    DOI 10.1088/0029-5515/32/4/I07\n    \"\"\"\n\n    name: str\n    t_min: float  # [keV]\n    t_max: float  # [keV]\n    bg: float  # [keV**0.5]\n    mrc2: float  # [keV]\n    c: npt.NDArray\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.ReactionCrossSection","title":"<code>ReactionCrossSection</code>","text":"<p>Fusion reaction cross-section.</p> Source code in <code>tokamak_neutron_source/reactivity_data.py</code> <pre><code>class ReactionCrossSection:\n    \"\"\"Fusion reaction cross-section.\"\"\"\n\n    def __init__(self, file_name: str):\n        \"\"\"\n        Parameters\n        ----------\n        file_name:\n            Cross-sectional data file (ENDF format)\n\n        Raises\n        ------\n        ReactivityError\n            Data file path is not a file\n        \"\"\"\n        path = get_tns_path(\"data/cross_sections\")\n        path = Path(path, file_name)\n        if not path.is_file():\n            raise ReactivityError(f\"Cross-section data file {path} is not a file!\")\n\n        file = path.as_posix()\n        # Read in the cross section (in barn) as a function of energy (MeV).\n        energy, sigma = np.genfromtxt(file, comments=\"#\", skip_footer=2, unpack=True)\n\n        split = file_name.split(\".\", maxsplit=1)[0].split(\"_\")\n        collider, target = split[:2]\n        self.name = f\"{collider} + {target} -&gt; {split[2]} + {split[3]}\"\n\n        mass_1, mass_2 = MOLAR_MASSES[collider], MOLAR_MASSES[target]\n\n        self.reduced_mass = raw_uc(mass_1 * mass_2 / (mass_1 + mass_2), \"amu\", \"kg\")\n\n        # Convert to center of mass frame\n        # NOTE MC: Choice of target/collider thing makes Bosch-Hale line up...\n        energy *= mass_2 / (mass_1 + mass_2)\n\n        # Convert to kev / m^2\n        self._cross_section = interp1d(energy * 1e3, sigma * 1e-28)\n\n    def __call__(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"Get cross section at a give temperature\"\"\"  # noqa: DOC201\n        return self._cross_section(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.Reactions","title":"<code>Reactions</code>","text":"<p>               Bases: <code>tokamak_neutron_source.reactions.ReactionEnumMixin</code>, <code>enum.Enum</code></p> <p>Neutronic reaction channels.</p> Source code in <code>tokamak_neutron_source/reactions.py</code> <pre><code>class Reactions(ReactionEnumMixin, Enum):\n    \"\"\"Neutronic reaction channels.\"\"\"\n\n    D_T = ReactionData(\n        label=\"D + T \u2192 \u2074He + n\",\n        total_energy=E_DT_FUSION,\n        num_neutrons=1,\n        cross_section=DT_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DT_4HEN,\n        ballabio_spectrum=BALLABIO_DT_NEUTRON,\n    )\n    D_D = ReactionData(\n        label=\"D + D \u2192 \u00b3He + n\",\n        total_energy=E_DD_HE3N_FUSION,\n        num_neutrons=1,\n        cross_section=DD_HE3N_XS,\n        bosch_hale_coefficients=BOSCH_HALE_DD_3HEN,\n        ballabio_spectrum=BALLABIO_DD_NEUTRON,\n    )\n    T_T = ReactionData(\n        label=\"T + T \u2192 \u2074He + 2n\",\n        total_energy=E_TT_FUSION,\n        num_neutrons=2,\n        cross_section=TT_XS,\n        bosch_hale_coefficients=None,\n        ballabio_spectrum=None,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.Reactions.D_D","title":"<code>D_D = &lt;Reactions.D_D: ReactionData(label='D + D \u2192 \u00b3He + n', total_energy=5.237367559215132e-13, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5637b1750&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=2449.5, omega_0=82.542, energy_shift_coeffs=BallabioCoefficients(a1=4.69515, a2=-0.040729, a3=0.47, a4=0.81844), width_correction_coeffs=BallabioCoefficients(a1=0.0017013, a2=0.16888, a3=0.49, a4=0.0007946)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.Reactions.D_T","title":"<code>D_T = &lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.Reactions.T_T","title":"<code>T_T = &lt;Reactions.T_T: ReactionData(label='T + T \u2192 \u2074He + 2n', total_energy=1.8157845541890245e-12, num_neutrons=2, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc5391e7b10&gt;, bosch_hale_coefficients=None, ballabio_spectrum=None)&gt;</code>  <code>class-attribute</code>","text":"<p>Neutronic reaction channels.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.ReactivityError","title":"<code>ReactivityError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Reactivity error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class ReactivityError(TNSError):\n    \"\"\"Reactivity error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.density_weighted_reactivity","title":"<code>density_weighted_reactivity(temp_kev, density_d, density_t, density_he3, reaction=&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;, method=&lt;ReactivityMethod.BOSCH_HALE: 2&gt;)</code>","text":"<p>Calculate the density-weighted thermal reactivity of a fusion reaction in Maxwellian plasmas, \\t:math:<code>n_1 n_2 &lt;\\sigma v&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Temperature [keV]</p> required <code>density_d</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Deuterium density [m^-3]</p> required <code>density_t</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Tritium density [m^-3]</p> required <code>density_he3</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Helium-3 density [m^-3]</p> required <code>reaction</code> <code>str | Reactions | AneutronicReactions</code> <p>The fusion reaction</p> <code>&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09,  1.51361e-02,  7.51886e-02,  4.60643e-03,         1.35000e-02, -1.06750e-04,  1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code> <code>method</code> <code>ReactivityMethod</code> <p>The method to use when calculating the reactivity</p> <code>&lt;ReactivityMethod.BOSCH_HALE: 2&gt;</code> <p>Returns:</p> Type Description <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Density-weighted reactivity of the reaction at the specified temperature(s) [1/m^3/s]</p> Source code in <code>tokamak_neutron_source/reactivity.py</code> <pre><code>def density_weighted_reactivity(\n    temp_kev: float | npt.NDArray,\n    density_d: float | npt.NDArray,\n    density_t: float | npt.NDArray,\n    density_he3: float | npt.NDArray,\n    reaction: str | AllReactions = Reactions.D_T,\n    method: ReactivityMethod = ReactivityMethod.BOSCH_HALE,\n) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the density-weighted thermal reactivity of a fusion reaction in\n    Maxwellian plasmas, \\\\t:math:`n_1 n_2 &lt;\\\\sigma v&gt;`.\n\n    Parameters\n    ----------\n    temp_kev:\n        Temperature [keV]\n    density_d:\n        Deuterium density [m^-3]\n    density_t:\n        Tritium density [m^-3]\n    density_he3:\n        Helium-3 density [m^-3]\n    reaction:\n        The fusion reaction\n    method:\n        The method to use when calculating the reactivity\n\n    Returns\n    -------\n    :\n        Density-weighted reactivity of the reaction at the specified temperature(s)\n        [1/m^3/s]\n    \"\"\"\n    reaction = _parse_reaction(reaction)\n\n    match reaction:\n        case Reactions.D_D | AneutronicReactions.D_D:\n            n1_n2 = density_d * density_d / 2\n        case Reactions.D_T:\n            n1_n2 = density_d * density_t\n        case Reactions.T_T:\n            n1_n2 = density_t * density_t / 2\n        case AneutronicReactions.D_He3:\n            n1_n2 = density_d * density_he3\n        case _:\n            raise NotImplementedError(f\"Reaction {reaction} not implemented.\")\n\n    return n1_n2 * reactivity(temp_kev, reaction, method)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.reactivity","title":"<code>reactivity(temp_kev, reaction=&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;, method=&lt;ReactivityMethod.BOSCH_HALE: 2&gt;)</code>","text":"<p>Calculate the thermal reactivity of a fusion reaction in Maxwellian plasmas, \\t:math:<code>&lt;\\sigma v&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>temp_kev</code> <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Temperature [keV]</p> required <code>reaction</code> <code>str | Reactions | AneutronicReactions</code> <p>The fusion reaction</p> <code>&lt;Reactions.D_T: ReactionData(label='D + T \u2192 \u2074He + n', total_energy=2.8183035155819573e-12, num_neutrons=1, cross_section=&lt;tokamak_neutron_source.reactivity_data.ReactionCrossSection object at 0x7fc52adec850&gt;, bosch_hale_coefficients=BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09,  1.51361e-02,  7.51886e-02,  4.60643e-03,         1.35000e-02, -1.06750e-04,  1.36600e-05])), ballabio_spectrum=BallabioEnergySpectrum(energy_0=14021.0, omega_0=177.259, energy_shift_coeffs=BallabioCoefficients(a1=5.30509, a2=0.0024736, a3=1.84, a4=1.3818), width_correction_coeffs=BallabioCoefficients(a1=0.00051068, a2=0.0076223, a3=1.78, a4=8.7691e-05)))&gt;</code> <code>method</code> <code>ReactivityMethod</code> <p>The method to use when calculating the reactivity</p> <code>&lt;ReactivityMethod.BOSCH_HALE: 2&gt;</code> <p>Returns:</p> Type Description <code>float | ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Reactivity of the reaction at the specified temperature(s) [m^3/s]</p> Source code in <code>tokamak_neutron_source/reactivity.py</code> <pre><code>def reactivity(\n    temp_kev: float | npt.NDArray,\n    reaction: str | AllReactions = Reactions.D_T,\n    method: ReactivityMethod = ReactivityMethod.BOSCH_HALE,\n) -&gt; float | npt.NDArray:\n    \"\"\"\n    Calculate the thermal reactivity of a fusion reaction in Maxwellian plasmas,\n    \\\\t:math:`&lt;\\\\sigma v&gt;`.\n\n    Parameters\n    ----------\n    temp_kev:\n        Temperature [keV]\n    reaction:\n        The fusion reaction\n    method:\n        The method to use when calculating the reactivity\n\n    Returns\n    -------\n    :\n        Reactivity of the reaction at the specified temperature(s) [m^3/s]\n    \"\"\"\n    reaction = _parse_reaction(reaction)\n\n    match method:\n        case ReactivityMethod.BOSCH_HALE:\n            if reaction.bosch_hale_coefficients is not None:\n                return _reactivity_bosch_hale(temp_kev, reaction)\n\n            logger.warning(\n                f\"There is no Bosch-Hale parameterisation for reaction {reaction.name}, \"\n                \"returning reactivity calculated by cross-section.\"\n            )\n            return _reactivity_from_xs(temp_kev, reaction.cross_section)\n        case ReactivityMethod.XS:\n            return _reactivity_from_xs(temp_kev, reaction.cross_section)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity/#tokamak_neutron_source.reactivity.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/","title":"reactivity_data","text":"<p>Reactivity data.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.BOSCH_HALE_DD_3HEN","title":"<code>BOSCH_HALE_DD_3HEN = BoschHaleCoefficients(name='D + D --&gt; 3He + n', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([ 5.43360e-12, 5.85778e-03, 7.68222e-03, 0.00000e+00,-2.96400e-06, 0.00000e+00, 0.00000e+00]))</code>  <code>module-attribute</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.BOSCH_HALE_DD_TP","title":"<code>BOSCH_HALE_DD_TP = BoschHaleCoefficients(name='D + D --&gt; T + p', t_min=0.2, t_max=100.0, bg=31.397, mrc2=937814.0, c=array([5.65718e-12, 3.41267e-03, 1.99167e-03, 0.00000e+00, 1.05060e-05,0.00000e+00, 0.00000e+00]))</code>  <code>module-attribute</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.BOSCH_HALE_DT_4HEN","title":"<code>BOSCH_HALE_DT_4HEN = BoschHaleCoefficients(name='D + T --&gt; 4He + n', t_min=0.2, t_max=100.0, bg=34.3827, mrc2=1124656.0, c=array([ 1.17302e-09, 1.51361e-02, 7.51886e-02, 4.60643e-03,1.35000e-02, -1.06750e-04, 1.36600e-05]))</code>  <code>module-attribute</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.MOLAR_MASSES","title":"<code>MOLAR_MASSES = {'D': 2.01410177784, 'T': 3.01604928132, 'He': 4.002602, 'He3': 3.01602932197, 'n': 1.0086649171167301, 'p': 1.0072764676333197, 'e': 0.0005485799096195737}</code>  <code>module-attribute</code>","text":"<p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.ReactionCrossSection","title":"<code>ReactionCrossSection</code>","text":"<p>Fusion reaction cross-section.</p> Source code in <code>tokamak_neutron_source/reactivity_data.py</code> <pre><code>class ReactionCrossSection:\n    \"\"\"Fusion reaction cross-section.\"\"\"\n\n    def __init__(self, file_name: str):\n        \"\"\"\n        Parameters\n        ----------\n        file_name:\n            Cross-sectional data file (ENDF format)\n\n        Raises\n        ------\n        ReactivityError\n            Data file path is not a file\n        \"\"\"\n        path = get_tns_path(\"data/cross_sections\")\n        path = Path(path, file_name)\n        if not path.is_file():\n            raise ReactivityError(f\"Cross-section data file {path} is not a file!\")\n\n        file = path.as_posix()\n        # Read in the cross section (in barn) as a function of energy (MeV).\n        energy, sigma = np.genfromtxt(file, comments=\"#\", skip_footer=2, unpack=True)\n\n        split = file_name.split(\".\", maxsplit=1)[0].split(\"_\")\n        collider, target = split[:2]\n        self.name = f\"{collider} + {target} -&gt; {split[2]} + {split[3]}\"\n\n        mass_1, mass_2 = MOLAR_MASSES[collider], MOLAR_MASSES[target]\n\n        self.reduced_mass = raw_uc(mass_1 * mass_2 / (mass_1 + mass_2), \"amu\", \"kg\")\n\n        # Convert to center of mass frame\n        # NOTE MC: Choice of target/collider thing makes Bosch-Hale line up...\n        energy *= mass_2 / (mass_1 + mass_2)\n\n        # Convert to kev / m^2\n        self._cross_section = interp1d(energy * 1e3, sigma * 1e-28)\n\n    def __call__(self, temp_kev: float | npt.NDArray) -&gt; float | npt.NDArray:\n        \"\"\"Get cross section at a give temperature\"\"\"  # noqa: DOC201\n        return self._cross_section(temp_kev)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.BoschHaleCoefficients","title":"<code>BoschHaleCoefficients</code>","text":"<p>Bosch-Hale parameterisation dataclass.</p> <p>H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611 DOI 10.1088/0029-5515/32/4/I07</p> Source code in <code>tokamak_neutron_source/reactivity_data.py</code> <pre><code>@dataclass\nclass BoschHaleCoefficients:\n    \"\"\"\n    Bosch-Hale parameterisation dataclass.\n\n    H.-S. Bosch and G.M. Hale 1992 Nucl. Fusion 32 611\n    DOI 10.1088/0029-5515/32/4/I07\n    \"\"\"\n\n    name: str\n    t_min: float  # [keV]\n    t_max: float  # [keV]\n    bg: float  # [keV**0.5]\n    mrc2: float  # [keV]\n    c: npt.NDArray\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.ReactivityError","title":"<code>ReactivityError</code>","text":"<p>               Bases: <code>tokamak_neutron_source.error.TNSError</code></p> <p>Reactivity error class</p> Source code in <code>tokamak_neutron_source/error.py</code> <pre><code>class ReactivityError(TNSError):\n    \"\"\"Reactivity error class\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.DD_HE3N_XS","title":"<code>DD_HE3N_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.DD_TP_XS","title":"<code>DD_TP_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.DHE3_HEP_XS","title":"<code>DHE3_HEP_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.DT_XS","title":"<code>DT_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.TT_XS","title":"<code>TT_XS(temp_kev)</code>","text":"<p>Fusion reaction cross-section.</p>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.get_tns_path","title":"<code>get_tns_path(path='', subfolder='tokamak_neutron_source')</code>","text":"<p>Get a tns path of a module subfolder. Defaults to root folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The desired path from which to create a full path</p> <code>''</code> <code>subfolder</code> <code>str</code> <p>The subfolder (from the tokamak_neutron_source root) in which to create a path Defaults to the source code folder, but can be e.g. 'tests', or 'data'</p> <code>'tokamak_neutron_source'</code> <p>Returns:</p> Type Description <code>Path</code> <p>The full path to the desired <code>path</code> in the subfolder specified</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def get_tns_path(path: str = \"\", subfolder: str = \"tokamak_neutron_source\") -&gt; Path:\n    \"\"\"\n    Get a tns path of a module subfolder. Defaults to root folder.\n\n    Parameters\n    ----------\n    path:\n        The desired path from which to create a full path\n    subfolder:\n        The subfolder (from the tokamak_neutron_source root) in which to create a path\n        Defaults to the source code folder, but can be e.g. 'tests', or 'data'\n\n    Returns\n    -------\n    :\n        The full path to the desired `path` in the subfolder specified\n    \"\"\"\n    root = get_tns_root()\n    if \"egg\" in root:\n        return Path(f\"/{subfolder}\")\n\n    path = path.replace(\"/\", os.sep)\n    main_path = _get_relpath(root, subfolder)\n    return Path(_get_relpath(main_path, path))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/reactivity_data/#tokamak_neutron_source.reactivity_data.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/space/","title":"space","text":"<p>Space sampling</p>"},{"location":"source/reference/tokamak_neutron_source/space/#tokamak_neutron_source.space.ClosedFluxSurface","title":"<code>ClosedFluxSurface</code>","text":"<p>Closed poloidal magnetic flux surface.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>class ClosedFluxSurface:\n    \"\"\"Closed poloidal magnetic flux surface.\"\"\"\n\n    def __init__(self, x: np.ndarray, z: np.ndarray):\n        if not is_closed(x, z):\n            raise FluxSurfaceError(\"This is not a closed flux surface.\")\n        self.x = np.asarray(x, dtype=float)\n        self.z = np.asarray(z, dtype=float)\n\n    @cached_property\n    def center_of_mass(self) -&gt; tuple[float, float]:\n        \"\"\"\n        Centre of mass of the ClosedFluxSurface.\n\n        Returns\n        -------\n        com:\n            ClosedFluxSurface center of mass\n        \"\"\"\n        return get_centroid_2d(self.x, self.z)\n\n    @cached_property\n    def area(self) -&gt; float:\n        \"\"\"\n        Enclosed area of the ClosedFluxSurface.\n\n        Returns\n        -------\n        area:\n            ClosedFluxSurface enclosed poloidal area\n        \"\"\"\n        return get_area_2d(self.x, self.z)\n\n    @cached_property\n    def volume(self) -&gt; float:\n        \"\"\"\n        Volume of the ClosedFluxSurface.\n\n        Returns\n        -------\n        volume:\n            ClosedFluxSurface enclosed volume.\n        \"\"\"\n        return 2 * np.pi * self.area * self.center_of_mass[0]\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/space/#tokamak_neutron_source.space.ClosedFluxSurface.area","title":"<code>area</code>  <code>cached</code> <code>property</code>","text":"<p>Enclosed area of the ClosedFluxSurface.</p> <p>Returns:</p> Name Type Description <code>area</code> <code>float</code> <p>ClosedFluxSurface enclosed poloidal area</p>"},{"location":"source/reference/tokamak_neutron_source/space/#tokamak_neutron_source.space.ClosedFluxSurface.center_of_mass","title":"<code>center_of_mass</code>  <code>cached</code> <code>property</code>","text":"<p>Centre of mass of the ClosedFluxSurface.</p> <p>Returns:</p> Name Type Description <code>com</code> <code>tuple[float, float]</code> <p>ClosedFluxSurface center of mass</p>"},{"location":"source/reference/tokamak_neutron_source/space/#tokamak_neutron_source.space.ClosedFluxSurface.volume","title":"<code>volume</code>  <code>cached</code> <code>property</code>","text":"<p>Volume of the ClosedFluxSurface.</p> <p>Returns:</p> Name Type Description <code>volume</code> <code>float</code> <p>ClosedFluxSurface enclosed volume.</p>"},{"location":"source/reference/tokamak_neutron_source/space/#tokamak_neutron_source.space.FluxPoint","title":"<code>FluxPoint</code>","text":"<p>Single poloidal magnetic flux point.</p> Source code in <code>tokamak_neutron_source/flux.py</code> <pre><code>@dataclass\nclass FluxPoint:\n    \"\"\"Single poloidal magnetic flux point.\"\"\"\n\n    x: float\n    z: float\n    psi: float\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/space/#tokamak_neutron_source.space.sample_space_2d","title":"<code>sample_space_2d(lcfs, o_point, cell_side_length)</code>","text":"<p>Sample the 2-D poloidal plane within the LCFS.</p> <p>Parameters:</p> Name Type Description Default <code>lcfs</code> <code>ClosedFluxSurface</code> <p>Last closed flux surface</p> required <code>o_point</code> <code>FluxPoint</code> <p>O-point location</p> required <code>cell_side_length</code> <code>float</code> <p>Side length of square cells [m]</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Radial coordinates of sampled points [m]</p> <code>z</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Vertical coordinates of sampled points [m]</p> <code>d_volume</code> <code>ndarray[tuple[Any, ...], dtype[~_ScalarT]]</code> <p>Volumes of cells centred at points [m^3]</p> Notes <p>Creates points at the centres of square cells of fixed size (cell_side_length by cell_side_length). Only cells whose centres fall inside the LCFS polygon are kept. Cells are positioned such that the  centre of one cell lies on the O-point.</p> Source code in <code>tokamak_neutron_source/space.py</code> <pre><code>def sample_space_2d(\n    lcfs: ClosedFluxSurface,\n    o_point: FluxPoint,\n    cell_side_length: float,\n) -&gt; tuple[npt.NDArray, npt.NDArray, npt.NDArray]:\n    \"\"\"\n    Sample the 2-D poloidal plane within the LCFS.\n\n    Parameters\n    ----------\n    lcfs:\n        Last closed flux surface\n    o_point:\n        O-point location\n    cell_side_length:\n        Side length of square cells [m]\n\n    Returns\n    -------\n    x:\n        Radial coordinates of sampled points [m]\n    z:\n        Vertical coordinates of sampled points [m]\n    d_volume:\n        Volumes of cells centred at points [m^3]\n\n    Notes\n    -----\n    Creates points at the centres of square cells of fixed size\n    (cell_side_length by cell_side_length). Only cells whose centres fall\n    inside the LCFS polygon are kept.\n    Cells are positioned such that the  centre of one cell lies on\n    the O-point.\n    \"\"\"\n    # Get bounding box around LCFS (+ offset)\n    polygon_path = Path(np.c_[lcfs.x, lcfs.z])\n    off = 2.0 * cell_side_length  # Just to be sure\n    x_min, x_max = np.min(lcfs.x) - off, np.max(lcfs.x) + off\n    z_min, z_max = np.min(lcfs.z) - off, np.max(lcfs.z) + off\n\n    # Shift grid so O-point lies on a cell center\n    dx = (o_point.x - x_min) % cell_side_length - 0.5 * cell_side_length\n    dz = (o_point.z - z_min) % cell_side_length - 0.5 * cell_side_length\n\n    # Construct grid\n    x_centers = np.arange(x_min + dx, x_max, cell_side_length) + 0.5 * cell_side_length\n    z_centers = np.arange(z_min + dz, z_max, cell_side_length) + 0.5 * cell_side_length\n    x, z = np.meshgrid(x_centers, z_centers, indexing=\"ij\")\n    points = np.c_[x.ravel(), z.ravel()]\n\n    # Mask by LCFS polygon\n    inside = polygon_path.contains_points(points)\n    points = points[inside]\n\n    # Volumes: toroidal rotation of each square cell\n    d_volume = 2 * np.pi * points[:, 0] * cell_side_length**2\n\n    return points[:, 0], points[:, 1], d_volume\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/","title":"tools","text":"<p>Tools.</p>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.SimpleJETTOOutput","title":"<code>SimpleJETTOOutput</code>","text":"<p>Dataclass for a simplified subset of JETTO output at a single timestamp.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>@dataclass\nclass SimpleJETTOOutput:\n    \"\"\"Dataclass for a simplified subset of JETTO output at a single timestamp.\"\"\"\n\n    \"\"\"Normalised rho coordinate profile: sqrt(poloidal flux)\"\"\"\n    rho: npt.NDArray\n\n    \"\"\"Ion temperature profile [keV]\"\"\"\n    ion_temperature: npt.NDArray\n\n    \"\"\"Deuterium density profile [1/m^3]\"\"\"\n    d_density: npt.NDArray\n\n    \"\"\"Tritium density profile [1/m^3]\"\"\"\n    t_density: npt.NDArray\n\n    \"\"\"Helium-3 density profile [1/m^3]\"\"\"\n    he3_density: npt.NDArray\n\n    \"\"\"D-T neutron rate [1/s]\"\"\"\n    dt_neutron_rate: float\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.WarningFilter","title":"<code>WarningFilter</code>","text":"<p>Filters away duplicate log messages. Source: https://stackoverflow.com/questions/31953272/60462619#60462619</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>class WarningFilter:\n    \"\"\"\n    Filters away duplicate log messages.\n    Source: https://stackoverflow.com/questions/31953272/60462619#60462619\n    \"\"\"\n\n    def __init__(self, *names: str):\n        self.msgs = set()\n        self.loggers = [logging.getLogger(name) for name in names]\n\n    def filter(self, record):  # noqa: D102\n        msg = str(record.msg)\n        is_duplicate = msg in self.msgs\n        if not is_duplicate:\n            self.msgs.add(msg)\n        return not is_duplicate\n\n    def __enter__(self):  # noqa: D105\n        for logger in self.loggers:\n            logger.addFilter(self)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):  # noqa: D105\n        for logger in self.loggers:\n            logger.removeFilter(self)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.WarningFilter.filter","title":"<code>filter(record)</code>","text":"Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def filter(self, record):  # noqa: D102\n    msg = str(record.msg)\n    is_duplicate = msg in self.msgs\n    if not is_duplicate:\n        self.msgs.add(msg)\n    return not is_duplicate\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.QuietTTSpectrumWarnings","title":"<code>QuietTTSpectrumWarnings</code>","text":"<p>               Bases: <code>tokamak_neutron_source.tools.WarningFilter</code></p> <p>Filter away all duplicate warnings from the energy and energy_data module.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>class QuietTTSpectrumWarnings(WarningFilter):\n    \"\"\"Filter away all duplicate warnings from the energy and energy_data module.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            \"tokamak_neutron_source.energy\", \"tokamak_neutron_source.energy_data\"\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.get_tns_root","title":"<code>get_tns_root()</code>","text":"<p>Get the tokamak_neutron_source root install folder.</p> <p>Returns:</p> Type Description <code>str</code> <p>The full path to the tokamak_neutron_source root folder, e.g.:     '/home/user/code/tokamak_neutron_source'</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def get_tns_root() -&gt; str:\n    \"\"\"\n    Get the tokamak_neutron_source root install folder.\n\n    Returns\n    -------\n    :\n        The full path to the tokamak_neutron_source root folder, e.g.:\n            '/home/user/code/tokamak_neutron_source'\n    \"\"\"\n    import tokamak_neutron_source  # noqa: PLC0415\n\n    path = next(iter(tokamak_neutron_source.__path__))\n    return os.path.split(path)[0]\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.get_tns_path","title":"<code>get_tns_path(path='', subfolder='tokamak_neutron_source')</code>","text":"<p>Get a tns path of a module subfolder. Defaults to root folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The desired path from which to create a full path</p> <code>''</code> <code>subfolder</code> <code>str</code> <p>The subfolder (from the tokamak_neutron_source root) in which to create a path Defaults to the source code folder, but can be e.g. 'tests', or 'data'</p> <code>'tokamak_neutron_source'</code> <p>Returns:</p> Type Description <code>Path</code> <p>The full path to the desired <code>path</code> in the subfolder specified</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def get_tns_path(path: str = \"\", subfolder: str = \"tokamak_neutron_source\") -&gt; Path:\n    \"\"\"\n    Get a tns path of a module subfolder. Defaults to root folder.\n\n    Parameters\n    ----------\n    path:\n        The desired path from which to create a full path\n    subfolder:\n        The subfolder (from the tokamak_neutron_source root) in which to create a path\n        Defaults to the source code folder, but can be e.g. 'tests', or 'data'\n\n    Returns\n    -------\n    :\n        The full path to the desired `path` in the subfolder specified\n    \"\"\"\n    root = get_tns_root()\n    if \"egg\" in root:\n        return Path(f\"/{subfolder}\")\n\n    path = path.replace(\"/\", os.sep)\n    main_path = _get_relpath(root, subfolder)\n    return Path(_get_relpath(main_path, path))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.load_eqdsk","title":"<code>load_eqdsk(file)</code>","text":"<p>Load an EQDSK file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | EQDSKInterface</code> <p>The path to the EQDSK file.</p> required <p>Returns:</p> Type Description <code>EQDSKInterface</code> <p>The EQDSKInterface object.</p> Notes <p>Enforces the local convention that psi on axis is higher than psi on the boundary. This way, we do not need to ask the user what COCOS convention they are using.</p> <p>The actual values of psi are irrelevant here, and may be changed to enforce this convention.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def load_eqdsk(file: str | EQDSKInterface) -&gt; EQDSKInterface:\n    \"\"\"\n    Load an EQDSK file.\n\n    Parameters\n    ----------\n    file:\n        The path to the EQDSK file.\n\n    Returns\n    -------\n    :\n        The EQDSKInterface object.\n\n    Notes\n    -----\n    Enforces the local convention that psi on axis is higher than\n    psi on the boundary. This way, we do not need to ask the user\n    what COCOS convention they are using.\n\n    The actual values of psi are irrelevant here, and may be changed\n    to enforce this convention.\n    \"\"\"\n    eq = EQDSKInterface.from_file(file, no_cocos=True) if isinstance(file, str) else file\n\n    if eq.psimag &lt; eq.psibdry:\n        offset = eq.psimag\n        eq.psi = offset - eq.psi\n        eq.psibdry = offset - eq.psibdry\n        eq.psimag = 0.0\n    return eq\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.load_jsp","title":"<code>load_jsp(file, frame_number=-1)</code>","text":"<p>Load a JETTO JSP binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>File to read</p> required <code>frame_number</code> <code>int</code> <p>Frame number to read</p> <code>-1</code> <p>Returns:</p> Type Description <code>SimpleJETTOOutput</code> <p>Simplified JETTO output</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified frame number is invalid.</p> Notes <p>For details, refer to https://users.euro-fusion.org/pages/data-cmg/wiki/JETTO_ppfjsp.html</p> <p>The core values (rho = 0.0) are not provided by JETTO. Here we extrapolate them.</p> <p>JETTO presently does not provide Helium-3 densities. These are taken to be 0.0.</p> <p>JETTO presently does not provide D-D fusion power or reaction rates, or some files may potentially do some but only for one of the channels.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def load_jsp(file: str | Path, frame_number: int = -1) -&gt; SimpleJETTOOutput:\n    \"\"\"\n    Load a JETTO JSP binary file.\n\n    Parameters\n    ----------\n    file:\n        File to read\n    frame_number:\n        Frame number to read\n\n    Returns\n    -------\n    :\n        Simplified JETTO output\n\n    Raises\n    ------\n    ValueError\n        If the specified frame number is invalid.\n\n    Notes\n    -----\n    For details, refer to\n    https://users.euro-fusion.org/pages/data-cmg/wiki/JETTO_ppfjsp.html\n\n    The core values (rho = 0.0) are not provided by JETTO. Here we extrapolate\n    them.\n\n    JETTO presently does not provide Helium-3 densities. These are taken to\n    be 0.0.\n\n    JETTO presently does not provide D-D fusion power or reaction rates, or\n    some files may potentially do some but only for one of the channels.\n    \"\"\"\n    from jetto_tools.binary import read_binary_file  # noqa: PLC0415\n\n    jsp = read_binary_file(file)\n\n    time_stamps = jsp[\"TIME\"][:, 0, 0]  # times when the snapshots are made\n\n    if frame_number &lt; -1 or frame_number &gt; len(time_stamps) - 1:\n        raise ValueError(f\"This JETTO file does not have a frame number: {frame_number}\")\n    t_index = len(time_stamps) - 1 if frame_number == -1 else frame_number\n\n    rho = jsp[\"XPSQ\"][t_index, :]  # Sqrt(poloidal magnetic flux)\n    ion_temperature = jsp[\"TI\"][t_index, :]\n    d_density = jsp[\"NID\"][t_index, :]\n    t_density = jsp[\"NIT\"][t_index, :]\n    he3_density = np.zeros_like(rho)  # JETTO does not provide 3-He density\n\n    # Here we treat the core, as JETTO at present does not provide data at rho = 0.0\n    rho = np.insert(rho, 0, 0.0)\n    ion_temperature = np.insert(ion_temperature, 0, ion_temperature[0])\n    d_density = np.insert(d_density, 0, d_density[0])\n    t_density = np.insert(t_density, 0, t_density[0])\n    he3_density = np.insert(he3_density, 0, he3_density[0])\n\n    ion_temperature = raw_uc(ion_temperature, \"eV\", \"keV\")\n\n    # Cumulative vectors for fusion power and neutron rate\n    dt_neutron_rate = jsp[\"R00\"][t_index, -1]\n\n    return SimpleJETTOOutput(\n        rho=rho,\n        ion_temperature=ion_temperature,\n        d_density=d_density,\n        t_density=t_density,\n        he3_density=he3_density,\n        dt_neutron_rate=dt_neutron_rate,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.load_citation","title":"<code>load_citation()</code>","text":"<p>Load the CITATION.cff file.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The contents of the CITATION.cff file as a dictionary.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def load_citation() -&gt; dict:\n    \"\"\"\n    Load the CITATION.cff file.\n\n    Returns\n    -------\n    :\n        The contents of the CITATION.cff file as a dictionary.\n    \"\"\"\n    with open(get_tns_path(\"data\") / \"CITATION.cff\") as citation_file:\n        return yaml.safe_load(citation_file)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.check_ccw","title":"<code>check_ccw(x, z)</code>","text":"<p>Check that a set of x, z coordinates are counter-clockwise.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The x coordinates of the polygon</p> required <code>z</code> <code>ndarray</code> <p>The z coordinates of the polygon</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if polygon counterclockwise</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>@nb.jit(cache=True, nopython=True)\ndef check_ccw(x: np.ndarray, z: np.ndarray) -&gt; bool:\n    \"\"\"\n    Check that a set of x, z coordinates are counter-clockwise.\n\n    Parameters\n    ----------\n    x:\n        The x coordinates of the polygon\n    z:\n        The z coordinates of the polygon\n\n    Returns\n    -------\n    :\n        True if polygon counterclockwise\n    \"\"\"\n    a = 0\n    for n in range(len(x) - 1):\n        a += (x[n + 1] - x[n]) * (z[n + 1] + z[n])\n    return a &lt; 0\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.get_area_2d","title":"<code>get_area_2d(x, y)</code>","text":"<p>Calculate the area inside a closed polygon with x, y coordinate vectors. <code>Link Shoelace method &lt;https://en.wikipedia.org/wiki/Shoelace_formula&gt;</code>_</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The first set of coordinates [m]</p> required <code>y</code> <code>ndarray</code> <p>The second set of coordinates [m]</p> required <p>Returns:</p> Type Description <code>float</code> <p>The area of the polygon [m^2]</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>@nb.jit(cache=True, nopython=True)\ndef get_area_2d(x: np.ndarray, y: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculate the area inside a closed polygon with x, y coordinate vectors.\n    `Link Shoelace method &lt;https://en.wikipedia.org/wiki/Shoelace_formula&gt;`_\n\n    Parameters\n    ----------\n    x:\n        The first set of coordinates [m]\n    y:\n        The second set of coordinates [m]\n\n    Returns\n    -------\n    :\n        The area of the polygon [m^2]\n    \"\"\"\n    # No np.roll in numba\n    x = np.ascontiguousarray(x.astype(np.float64))\n    y = np.ascontiguousarray(y.astype(np.float64))\n    x1 = np.append(x[-1], x[:-1])\n    y1 = np.append(y[-1], y[:-1])\n    return 0.5 * np.abs(np.dot(x, y1) - np.dot(y, x1))\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.get_centroid_2d","title":"<code>get_centroid_2d(x, z)</code>","text":"<p>Calculate the centroid of a non-self-intersecting 2-D counter-clockwise polygon.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x coordinates of the coordinates to calculate on</p> required <code>z</code> <code>ndarray</code> <p>z coordinates of the coordinates to calculate on</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The x, z coordinates of the centroid [m]</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>@nb.jit(cache=True, nopython=True)\ndef get_centroid_2d(x: np.ndarray, z: np.ndarray) -&gt; list[float]:\n    \"\"\"\n    Calculate the centroid of a non-self-intersecting 2-D counter-clockwise polygon.\n\n    Parameters\n    ----------\n    x:\n        x coordinates of the coordinates to calculate on\n    z:\n        z coordinates of the coordinates to calculate on\n\n    Returns\n    -------\n    :\n        The x, z coordinates of the centroid [m]\n    \"\"\"\n    if not check_ccw(x, z):\n        x = np.ascontiguousarray(x[::-1])\n        z = np.ascontiguousarray(z[::-1])\n    area = get_area_2d(x, z)\n\n    cx, cz = 0, 0\n    for i in range(len(x) - 1):\n        a = x[i] * z[i + 1] - x[i + 1] * z[i]\n        cx += (x[i] + x[i + 1]) * a\n        cz += (z[i] + z[i + 1]) * a\n\n    if area != 0:\n        # Zero division protection\n        cx /= 6 * area\n        cz /= 6 * area\n\n    return [cx, cz]\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/tools/#tokamak_neutron_source.tools.raw_uc","title":"<code>raw_uc(value, unit_from, unit_to)</code>","text":"<p>Raw unit converter Converts a value from one unit to another</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ValueLikeT</code> <p>value to convert</p> required <code>unit_from</code> <code>str | Unit</code> <p>unit to convert from</p> required <code>unit_to</code> <code>str | Unit</code> <p>unit to convert to</p> required <p>Returns:</p> Type Description <code>ValueLikeT</code> <p>converted value</p> Source code in <code>tokamak_neutron_source/constants.py</code> <pre><code>def raw_uc(\n    value: ValueLikeT,\n    unit_from: str | ureg.Unit,\n    unit_to: str | ureg.Unit,\n) -&gt; ValueLikeT:\n    \"\"\"\n    Raw unit converter\n    Converts a value from one unit to another\n\n    Parameters\n    ----------\n    value:\n        value to convert\n    unit_from:\n        unit to convert from\n    unit_to:\n        unit to convert to\n\n    Returns\n    -------\n    :\n        converted value\n    \"\"\"\n    try:\n        return (\n            ureg.Quantity(value, ureg.Unit(unit_from)).to(ureg.Unit(unit_to)).magnitude\n        )\n    except ValueError:\n        # Catch scales on units eg the ridculousness of this unit: 10^19/m^3\n        unit_from_q = ureg.Quantity(unit_from)\n        unit_to_q = ureg.Quantity(unit_to)\n        return (\n            ureg.Quantity(value * unit_from_q).to(unit_to_q.units).magnitude\n            / unit_to_q.magnitude\n        )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/","title":"transport","text":"<p>Transport data structures.</p>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.DT_5050_MIXTURE","title":"<code>DT_5050_MIXTURE = FractionalFuelComposition(D=0.5, T=0.5, He3=0.0)</code>  <code>module-attribute</code>","text":"<p>Fractional fuel composition dataclass.</p> Notes <p>Fuel fractions are taken to be constant along the profile. Note that the D-He-3 reaction is aneutronic, but dilutes the fuel in the case that it is included in the fuel density profile.</p>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.annotations","title":"<code>annotations = _Feature((3, 7, 0, 'beta', 1), None, 16777216)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.FractionalFuelComposition","title":"<code>FractionalFuelComposition</code>","text":"<p>Fractional fuel composition dataclass.</p> Notes <p>Fuel fractions are taken to be constant along the profile. Note that the D-He-3 reaction is aneutronic, but dilutes the fuel in the case that it is included in the fuel density profile.</p> Source code in <code>tokamak_neutron_source/transport.py</code> <pre><code>@dataclass\nclass FractionalFuelComposition:\n    \"\"\"\n    Fractional fuel composition dataclass.\n\n    Notes\n    -----\n    Fuel fractions are taken to be constant along the profile.\n    Note that the D-He-3 reaction is aneutronic, but dilutes the fuel\n    in the case that it is included in the fuel density profile.\n    \"\"\"\n\n    \"\"\"Deuterium fuel fraction\"\"\"\n    D: float\n\n    \"\"\"Tritium fuel fraction\"\"\"\n    T: float\n\n    \"\"\"Helium-3 fuel fraction\"\"\"\n    He3: float = 0.0\n\n    def __post_init__(self):\n        \"\"\"Force fractions to sum to 1.0.\"\"\"\n        if not np.equal(sum(astuple(self)), 1.0):\n            norm = sum(astuple(self))\n            self.D, self.T, self.He3 = self.D / norm, self.T / norm, self.He3 / norm\n            logger.warning(\n                f\"Fuel fraction has been renormalized to: {self}\",\n                stacklevel=1,\n            )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.FractionalFuelComposition.He3","title":"<code>He3 = 0.0</code>  <code>class-attribute</code>","text":"<p>Convert a string or number to a floating point number, if possible.</p>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.TransportInformation","title":"<code>TransportInformation</code>","text":"<p>Transport information.</p> Source code in <code>tokamak_neutron_source/transport.py</code> <pre><code>@dataclass\nclass TransportInformation:\n    \"\"\"Transport information.\"\"\"\n\n    deuterium_density_profile: PlasmaProfile  # [1/m^3]\n    tritium_density_profile: PlasmaProfile  # [1/m^3]\n    helium3_density_profile: PlasmaProfile  # [1/m^3]\n    temperature_profile: PlasmaProfile  # [keV]\n    rho_profile: npt.NDArray  # [0..1]\n\n    @classmethod\n    def from_profiles(\n        cls,\n        ion_temperature_profile: np.ndarray,\n        fuel_density_profile: np.ndarray,\n        rho_profile: np.ndarray,\n        fuel_composition: FractionalFuelComposition = DT_5050_MIXTURE,\n    ) -&gt; TransportInformation:\n        \"\"\"\n        Instantiate TransportInformation from profile arrays.\n\n        Parameters\n        ----------\n        ion_temperature_profile:\n            Ion temperature profile [keV]\n        fuel_density_profile:\n            Fuel density profile [1/m^3]\n        rho_profile:\n            Normalised radial coordinate profile\n        fuel_composition\n            Fractional fuel composition (constant fraction across profile)\n\n        \"\"\"  # noqa: DOC201\n        return cls(\n            DataProfile(\n                fuel_composition.D * fuel_density_profile,\n                rho_profile,\n            ),\n            DataProfile(\n                fuel_composition.T * fuel_density_profile,\n                rho_profile,\n            ),\n            DataProfile(\n                fuel_composition.He3 * fuel_density_profile,\n                rho_profile,\n            ),\n            DataProfile(ion_temperature_profile, rho_profile),\n            np.asarray(rho_profile),\n        )\n\n    @classmethod\n    def from_parameterisations(\n        cls,\n        ion_temperature_profile: PlasmaProfile,\n        fuel_density_profile: PlasmaProfile,\n        rho_profile: npt.NDArray,\n        fuel_composition: FractionalFuelComposition = DT_5050_MIXTURE,\n    ) -&gt; TransportInformation:\n        \"\"\"\n        Instantiate TransportInformation from profile parameterisations.\n\n        Parameters\n        ----------\n        ion_temperature_profile:\n            Ion temperature profile parameterisation\n        fuel_density_profile:\n            Fuel density profile parameterisation\n        rho_profile:\n            Noramlised radial coordinate profile\n        fuel_composition\n            Fractional fuel composition (constant fraction across profile)\n\n        \"\"\"  # noqa: DOC201\n        d_profile = deepcopy(fuel_density_profile)\n        d_profile.set_scale(fuel_composition.D)\n        t_profile = deepcopy(fuel_density_profile)\n        t_profile.set_scale(fuel_composition.T)\n        he3_profile = deepcopy(fuel_density_profile)\n        he3_profile.set_scale(fuel_composition.He3)\n\n        return cls(\n            d_profile,\n            t_profile,\n            he3_profile,\n            ion_temperature_profile,\n            rho_profile,\n        )\n\n    @classmethod\n    def from_jetto(cls, jsp_file: str, frame_number: int = -1) -&gt; TransportInformation:\n        \"\"\"\n        Instantiate TransportInformation from JETTO file.\n\n        Parameters\n        ----------\n        jsp_file:\n            Path to the JETTO .jsp file\n        frame_number:\n            The specific time-slice of the JETTO run that we want to investigate.\n            This ensures that all of the extracted quantities are describing the same\n            point in time.\n        \"\"\"  # noqa: DOC201\n        data = load_jsp(jsp_file, frame_number)\n\n        return cls(\n            DataProfile(\n                data.d_density,\n                data.rho,\n            ),\n            DataProfile(\n                data.t_density,\n                data.rho,\n            ),\n            DataProfile(\n                data.he3_density,\n                data.rho,\n            ),\n            DataProfile(data.ion_temperature, data.rho),\n            data.rho,\n        )\n\n    def plot(self) -&gt; tuple[plt.Figure, plt.Axes]:\n        \"\"\"\n        Plot the TransportInformation\n\n        Returns\n        -------\n        f:\n            Matplotlib Figure object\n        ax:\n            Matplotlib Axes object\n        \"\"\"\n        f, ax = plt.subplots()\n\n        d_d = self.deuterium_density_profile.value(self.rho_profile)\n        d_t = self.tritium_density_profile.value(self.rho_profile)\n        d_he3 = self.helium3_density_profile.value(self.rho_profile)\n\n        for d, label, ls in zip(\n            [d_d, d_t, d_he3], [\"D\", \"T\", \"\u00b3He\"], [\"-.\", \"--\", \".\"], strict=True\n        ):\n            if not np.allclose(d, 0.0):\n                ax.plot(self.rho_profile, d, ls=ls, label=label)\n        ax.set_xlabel(r\"$\\rho$\")\n        ax.set_ylabel(r\"$n$ [1/m$^{3}$]\")\n        ax.legend(loc=\"lower left\")\n        ax2 = ax.twinx()\n        ax2.plot(\n            self.rho_profile,\n            self.temperature_profile.value(self.rho_profile),\n            label=r\"$T_{i}$\",\n            color=\"r\",\n        )\n        ax2.set_ylabel(r\"$T_{i}$ [keV]\")\n        ax2.legend(loc=\"upper right\")\n        plt.show()\n        return f, ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.TransportInformation.from_profiles","title":"<code>from_profiles(ion_temperature_profile, fuel_density_profile, rho_profile, fuel_composition=FractionalFuelComposition(D=0.5, T=0.5, He3=0.0))</code>  <code>classmethod</code>","text":"<p>Instantiate TransportInformation from profile arrays.</p> <p>Parameters:</p> Name Type Description Default <code>ion_temperature_profile</code> <code>ndarray</code> <p>Ion temperature profile [keV]</p> required <code>fuel_density_profile</code> <code>ndarray</code> <p>Fuel density profile [1/m^3]</p> required <code>rho_profile</code> <code>ndarray</code> <p>Normalised radial coordinate profile</p> required <code>fuel_composition</code> <code>FractionalFuelComposition</code> <p>Fractional fuel composition (constant fraction across profile)</p> <code>FractionalFuelComposition(D=0.5, T=0.5, He3=0.0)</code> Source code in <code>tokamak_neutron_source/transport.py</code> <pre><code>@classmethod\ndef from_profiles(\n    cls,\n    ion_temperature_profile: np.ndarray,\n    fuel_density_profile: np.ndarray,\n    rho_profile: np.ndarray,\n    fuel_composition: FractionalFuelComposition = DT_5050_MIXTURE,\n) -&gt; TransportInformation:\n    \"\"\"\n    Instantiate TransportInformation from profile arrays.\n\n    Parameters\n    ----------\n    ion_temperature_profile:\n        Ion temperature profile [keV]\n    fuel_density_profile:\n        Fuel density profile [1/m^3]\n    rho_profile:\n        Normalised radial coordinate profile\n    fuel_composition\n        Fractional fuel composition (constant fraction across profile)\n\n    \"\"\"  # noqa: DOC201\n    return cls(\n        DataProfile(\n            fuel_composition.D * fuel_density_profile,\n            rho_profile,\n        ),\n        DataProfile(\n            fuel_composition.T * fuel_density_profile,\n            rho_profile,\n        ),\n        DataProfile(\n            fuel_composition.He3 * fuel_density_profile,\n            rho_profile,\n        ),\n        DataProfile(ion_temperature_profile, rho_profile),\n        np.asarray(rho_profile),\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.TransportInformation.from_parameterisations","title":"<code>from_parameterisations(ion_temperature_profile, fuel_density_profile, rho_profile, fuel_composition=FractionalFuelComposition(D=0.5, T=0.5, He3=0.0))</code>  <code>classmethod</code>","text":"<p>Instantiate TransportInformation from profile parameterisations.</p> <p>Parameters:</p> Name Type Description Default <code>ion_temperature_profile</code> <code>PlasmaProfile</code> <p>Ion temperature profile parameterisation</p> required <code>fuel_density_profile</code> <code>PlasmaProfile</code> <p>Fuel density profile parameterisation</p> required <code>rho_profile</code> <code>NDArray</code> <p>Noramlised radial coordinate profile</p> required <code>fuel_composition</code> <code>FractionalFuelComposition</code> <p>Fractional fuel composition (constant fraction across profile)</p> <code>FractionalFuelComposition(D=0.5, T=0.5, He3=0.0)</code> Source code in <code>tokamak_neutron_source/transport.py</code> <pre><code>@classmethod\ndef from_parameterisations(\n    cls,\n    ion_temperature_profile: PlasmaProfile,\n    fuel_density_profile: PlasmaProfile,\n    rho_profile: npt.NDArray,\n    fuel_composition: FractionalFuelComposition = DT_5050_MIXTURE,\n) -&gt; TransportInformation:\n    \"\"\"\n    Instantiate TransportInformation from profile parameterisations.\n\n    Parameters\n    ----------\n    ion_temperature_profile:\n        Ion temperature profile parameterisation\n    fuel_density_profile:\n        Fuel density profile parameterisation\n    rho_profile:\n        Noramlised radial coordinate profile\n    fuel_composition\n        Fractional fuel composition (constant fraction across profile)\n\n    \"\"\"  # noqa: DOC201\n    d_profile = deepcopy(fuel_density_profile)\n    d_profile.set_scale(fuel_composition.D)\n    t_profile = deepcopy(fuel_density_profile)\n    t_profile.set_scale(fuel_composition.T)\n    he3_profile = deepcopy(fuel_density_profile)\n    he3_profile.set_scale(fuel_composition.He3)\n\n    return cls(\n        d_profile,\n        t_profile,\n        he3_profile,\n        ion_temperature_profile,\n        rho_profile,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.TransportInformation.from_jetto","title":"<code>from_jetto(jsp_file, frame_number=-1)</code>  <code>classmethod</code>","text":"<p>Instantiate TransportInformation from JETTO file.</p> <p>Parameters:</p> Name Type Description Default <code>jsp_file</code> <code>str</code> <p>Path to the JETTO .jsp file</p> required <code>frame_number</code> <code>int</code> <p>The specific time-slice of the JETTO run that we want to investigate. This ensures that all of the extracted quantities are describing the same point in time.</p> <code>-1</code> Source code in <code>tokamak_neutron_source/transport.py</code> <pre><code>@classmethod\ndef from_jetto(cls, jsp_file: str, frame_number: int = -1) -&gt; TransportInformation:\n    \"\"\"\n    Instantiate TransportInformation from JETTO file.\n\n    Parameters\n    ----------\n    jsp_file:\n        Path to the JETTO .jsp file\n    frame_number:\n        The specific time-slice of the JETTO run that we want to investigate.\n        This ensures that all of the extracted quantities are describing the same\n        point in time.\n    \"\"\"  # noqa: DOC201\n    data = load_jsp(jsp_file, frame_number)\n\n    return cls(\n        DataProfile(\n            data.d_density,\n            data.rho,\n        ),\n        DataProfile(\n            data.t_density,\n            data.rho,\n        ),\n        DataProfile(\n            data.he3_density,\n            data.rho,\n        ),\n        DataProfile(data.ion_temperature, data.rho),\n        data.rho,\n    )\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.TransportInformation.plot","title":"<code>plot()</code>","text":"<p>Plot the TransportInformation</p> <p>Returns:</p> Name Type Description <code>f</code> <code>Figure</code> <p>Matplotlib Figure object</p> <code>ax</code> <code>Axes</code> <p>Matplotlib Axes object</p> Source code in <code>tokamak_neutron_source/transport.py</code> <pre><code>def plot(self) -&gt; tuple[plt.Figure, plt.Axes]:\n    \"\"\"\n    Plot the TransportInformation\n\n    Returns\n    -------\n    f:\n        Matplotlib Figure object\n    ax:\n        Matplotlib Axes object\n    \"\"\"\n    f, ax = plt.subplots()\n\n    d_d = self.deuterium_density_profile.value(self.rho_profile)\n    d_t = self.tritium_density_profile.value(self.rho_profile)\n    d_he3 = self.helium3_density_profile.value(self.rho_profile)\n\n    for d, label, ls in zip(\n        [d_d, d_t, d_he3], [\"D\", \"T\", \"\u00b3He\"], [\"-.\", \"--\", \".\"], strict=True\n    ):\n        if not np.allclose(d, 0.0):\n            ax.plot(self.rho_profile, d, ls=ls, label=label)\n    ax.set_xlabel(r\"$\\rho$\")\n    ax.set_ylabel(r\"$n$ [1/m$^{3}$]\")\n    ax.legend(loc=\"lower left\")\n    ax2 = ax.twinx()\n    ax2.plot(\n        self.rho_profile,\n        self.temperature_profile.value(self.rho_profile),\n        label=r\"$T_{i}$\",\n        color=\"r\",\n    )\n    ax2.set_ylabel(r\"$T_{i}$ [keV]\")\n    ax2.legend(loc=\"upper right\")\n    plt.show()\n    return f, ax\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.DataProfile","title":"<code>DataProfile</code>","text":"<p>               Bases: <code>tokamak_neutron_source.profile.PlasmaProfile</code></p> <p>Plasma profile from data.</p> Notes <p>Normalised radius conventions are not enforced here. Linear interpolation is used.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>class DataProfile(PlasmaProfile):\n    \"\"\"\n    Plasma profile from data.\n\n    Notes\n    -----\n    Normalised radius conventions are not enforced here.\n    Linear interpolation is used.\n    \"\"\"\n\n    def __init__(self, values: npt.NDArray, rho: npt.NDArray, *, scale: float = 1.0):\n        super().__init__(scale)\n        self._values = values\n        self._rho = rho\n        self._interpolator = interp1d(self._rho, self._values, kind=\"linear\")\n\n    def value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n        \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"  # noqa: DOC201\n        rho = np.clip(rho, 0.0, 1.0)\n        return self._scale * self._interpolator(rho)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.DataProfile.value","title":"<code>value(rho)</code>","text":"<p>Calculate the value of the profile at given value(s) of rho.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>def value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n    \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"  # noqa: DOC201\n    rho = np.clip(rho, 0.0, 1.0)\n    return self._scale * self._interpolator(rho)\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.PlasmaProfile","title":"<code>PlasmaProfile</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Abstract base class for plasma profiles.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>class PlasmaProfile(ABC):\n    \"\"\"Abstract base class for plasma profiles.\"\"\"\n\n    def __init__(self, scale: float = 1.0):\n        self._scale = scale\n\n    @abstractmethod\n    def value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n        \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"\n\n    def set_scale(self, scale: float = 1.0):\n        \"\"\"Set the scale of the rho value. Multiplies existing scale.\"\"\"\n        self._scale *= scale\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.PlasmaProfile.set_scale","title":"<code>set_scale(scale=1.0)</code>","text":"<p>Set the scale of the rho value. Multiplies existing scale.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>def set_scale(self, scale: float = 1.0):\n    \"\"\"Set the scale of the rho value. Multiplies existing scale.\"\"\"\n    self._scale *= scale\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.PlasmaProfile.value","title":"<code>value(rho)</code>","text":"<p>Calculate the value of the profile at given value(s) of rho.</p> Source code in <code>tokamak_neutron_source/profile.py</code> <pre><code>@abstractmethod\ndef value(self, rho: float | Iterable) -&gt; float | np.ndarray:\n    \"\"\"Calculate the value of the profile at given value(s) of rho.\"\"\"\n</code></pre>"},{"location":"source/reference/tokamak_neutron_source/transport/#tokamak_neutron_source.transport.load_jsp","title":"<code>load_jsp(file, frame_number=-1)</code>","text":"<p>Load a JETTO JSP binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>File to read</p> required <code>frame_number</code> <code>int</code> <p>Frame number to read</p> <code>-1</code> <p>Returns:</p> Type Description <code>SimpleJETTOOutput</code> <p>Simplified JETTO output</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified frame number is invalid.</p> Notes <p>For details, refer to https://users.euro-fusion.org/pages/data-cmg/wiki/JETTO_ppfjsp.html</p> <p>The core values (rho = 0.0) are not provided by JETTO. Here we extrapolate them.</p> <p>JETTO presently does not provide Helium-3 densities. These are taken to be 0.0.</p> <p>JETTO presently does not provide D-D fusion power or reaction rates, or some files may potentially do some but only for one of the channels.</p> Source code in <code>tokamak_neutron_source/tools.py</code> <pre><code>def load_jsp(file: str | Path, frame_number: int = -1) -&gt; SimpleJETTOOutput:\n    \"\"\"\n    Load a JETTO JSP binary file.\n\n    Parameters\n    ----------\n    file:\n        File to read\n    frame_number:\n        Frame number to read\n\n    Returns\n    -------\n    :\n        Simplified JETTO output\n\n    Raises\n    ------\n    ValueError\n        If the specified frame number is invalid.\n\n    Notes\n    -----\n    For details, refer to\n    https://users.euro-fusion.org/pages/data-cmg/wiki/JETTO_ppfjsp.html\n\n    The core values (rho = 0.0) are not provided by JETTO. Here we extrapolate\n    them.\n\n    JETTO presently does not provide Helium-3 densities. These are taken to\n    be 0.0.\n\n    JETTO presently does not provide D-D fusion power or reaction rates, or\n    some files may potentially do some but only for one of the channels.\n    \"\"\"\n    from jetto_tools.binary import read_binary_file  # noqa: PLC0415\n\n    jsp = read_binary_file(file)\n\n    time_stamps = jsp[\"TIME\"][:, 0, 0]  # times when the snapshots are made\n\n    if frame_number &lt; -1 or frame_number &gt; len(time_stamps) - 1:\n        raise ValueError(f\"This JETTO file does not have a frame number: {frame_number}\")\n    t_index = len(time_stamps) - 1 if frame_number == -1 else frame_number\n\n    rho = jsp[\"XPSQ\"][t_index, :]  # Sqrt(poloidal magnetic flux)\n    ion_temperature = jsp[\"TI\"][t_index, :]\n    d_density = jsp[\"NID\"][t_index, :]\n    t_density = jsp[\"NIT\"][t_index, :]\n    he3_density = np.zeros_like(rho)  # JETTO does not provide 3-He density\n\n    # Here we treat the core, as JETTO at present does not provide data at rho = 0.0\n    rho = np.insert(rho, 0, 0.0)\n    ion_temperature = np.insert(ion_temperature, 0, ion_temperature[0])\n    d_density = np.insert(d_density, 0, d_density[0])\n    t_density = np.insert(t_density, 0, t_density[0])\n    he3_density = np.insert(he3_density, 0, he3_density[0])\n\n    ion_temperature = raw_uc(ion_temperature, \"eV\", \"keV\")\n\n    # Cumulative vectors for fusion power and neutron rate\n    dt_neutron_rate = jsp[\"R00\"][t_index, -1]\n\n    return SimpleJETTOOutput(\n        rho=rho,\n        ion_temperature=ion_temperature,\n        d_density=d_density,\n        t_density=t_density,\n        he3_density=he3_density,\n        dt_neutron_rate=dt_neutron_rate,\n    )\n</code></pre>"}]}